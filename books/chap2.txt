	Основы языка cmake
	Основые концепции 
	Генераторы 
	Генераторами называются компоненты cmake, отвечающие за создание проектов для конечных систем построения.Для каждой поддерживаемой 
системы (make, visual studio) существует свой генератор.Выбор конкретного генератора задается в cli cmake при помощи ключа -G, например:
cmake -G "Visual Studio 14 2015" ..\project_src
	Здесь последний аргумент ..\project_src указывает утилите cmake с интерфейсом cli путь к катологу проекта.Текущий каталог, откуда запускает 
программа cmake, будет каталогом построеня, в котором будут сгенерированы файлы проектов.
	Реализация cmake для различных платформ могут поддерживтаь разные наборы генераторов для данной версии можно узнать при помощи команды:
cmake --help
	Кроме этого,некоторые генераторы поддерживают различные варанты в виде наборов инструментов(ключ -T) и платформ (ключ -A). Для совместимости 
с предыдущими версиями инструмента cmake возможно указание платформы в названии генератора.Например:
cmake -G "visual studio 11 2012" -A ARM ..\project_src
cmake -G "visual studio 11 2012 ARM" ..\project_src
или 
cmake -G "visual studio 11 2012" -A X64 ..\project_src
cmake -G "visual studio 11 2012 Win64" ..\project_src
	При отсутствии ключа -G к cli cmake выбирается некоторый генератор по умолчанию для данной платформы
	В именах генераторов для visual studio c++ можно опускать номер года.Например
cmake -G "visual studio 11 2012 Win64" ..\project_src
	Входные файлы
	Входными файлами на языке cmake являются файлы CMakeLists.txt, лежащие в корне каталога проекта(со всеми исходниками).Путь к катологу проекта передается 
в cli в качестве последнего аргумента.Круаные проекты могут также содержать подкаталоги с проектаим нижнего уровня, каждый из которых будет иметь в корне свой 
CMakeLists.txt файл.Каталоги с подпроектами подключаются из файла на языке cmake при попощи команды add_subdirectory().Для каждого обрабатываемого файла CMakeLists.txt 
система cmake создает в выходном каталоге подкаталог, служащий по умолчанию каталогом для промежуточных и выходных файлов этого (под)проекта, генерируя в нем все 
необходимые файлы для используемоый конечной системы построеня.
	Кроме файлов CMakeLists.txt также могут использоваться файлы с расширением .make.Эти файлы могут подключаться из программы на языке cmake при помощи директивы include(),
вызываться при исполнении команды find_package() или передаваться инструменту cmake для исполнения при помощи ключа командной строки -P.При исполнении этих файлов система cmake не создает 
отдельных выходных каталогов и не генерирует файлов для построения.
	В процессе генерирования файлов описания проектов cmake определяет в них зависимости от входных файлов.Изменения в них приведут при запуске построения конечной системой к повторному 
вызову инструмента cmake, который перегенерирует описания проектов.Таким образом, автоматически отслеживаются ситуации изменения входных файлов cmake.
	Пути 
	Следует обратить внимание на то что система cmake использует абсолютные пути везде где это возможно.В генерируемых файлах проектов для конечных систем построения содержатся абсолютные пути 
к исходным, промежуточным и конечным файлам.Определяемые пользователем пути поиска заголовочных файлов при генерировании преобразутся в абсолютные и тд.Специальные переменные, хранящие пути к файлам 
и каталогам(такие как CMAKE_SOURCE_DIR), содержат абсолютные пути.На платформах, файловые системы которых нечувствительны к регистру имен файлов, символы путей преобразуются к тому регистру, в котором 
они хранятся в системе.
	Такой подход ускоряет и упрощает процесс генерирования файлов для конечных систем построения.Например, для проверки того , указывают ли два пути на один и тот же файл или каталог, достаточно проверить 
эти строки на равенство.Кроме этого, генерируемые файлы реализуют требуемые от них ф-ции построения более надежным образом.Например,в make-файле указываются абсолютные пути к вызываемым инструментам, что делает 
процесс построения независимым от значения переменной окружения PATH и других общесистемных настроек.
	Однако исользование абсолютных путей также накладывает на разработчика определенные обязательства.Так , при перемещении каталога проекта или каталога построения в файловой системе приходится заново генерировать 
файлы повтроным запуском cmake.Понимание принципа использования абсолютных путей позволяет избежать многих типичных ошибок при использовании cmake в качестве системы построения проекта.
	Синтаксис
	Команды
	Программа на cmake состоит из последовательности команд, исполняемых интерпритатором.Синтаксис команды:
	<имя команды>([<аргумент1>...<аргумент2>])
	Замечание:аргументы команд разделяются символами-разделителями, а не запятыми.
	В качестве символа-разделителя могут использоваться один или несколько пробелов, символ табуляции и перевода строки.Таким образом, в отличие от make, qmake и тд при записи длинной команды в несколько строк
не нужно завершать каждую из них символом \.
	Языком поддерживаются однострочные комменты, начинаюзиеся с символа #.Также, начиная с cmake 3.0, поддерживаются блочные комменты между символами #[[ и ]]
	Команды являются единственным средством в языке, при помощи них, например, записываются все управляющие конструкции
	
if(WIN32)
	message(STATUS "Building for windows")
endif()

Замечание:все инструкции, включая endif() в примере выше, являются командами, поэтому после них необходимо ставить скобки.
	Как правило,команды поддерживают переменное количество аргументов
	Строки
	Аргументами команд являются строки.Как и в языках make и тд строки-это последовательности символови escape-последовательностей.Чтобы включить в строку символ-разделитель, можно заключить ее в двойные кавычки.В этом случае 
интерпритатор будет считать данне символы частью строки, а не разделителем аргументов.Строки в кавычках могут занимать несколько строк в тексте программы, при этом символ \ в конце строки текста приводит к тому что следующий за ним 
символ перевода строки не будет считаться частью строки.
	Пример 
message(
	"AB\nCD
	\tEF\
	GH \${DATA}\"\\#"
	)
выведет на консоль:
AB
CD
	EF GH ${DATA}"\#

-Команда выполняет первый перевод строки после символов AB, так как в строковой константе после них указан escape-символ \n
-следующий перевод строки после CD указан в строке явно
-следующая строка начинается с \t, символ перевода строки после EF подавляется символов \ в конце строки.Таким образом,после символа EF на печать выводится два пробела и смиволы GH
-за символами GH выводится пробел, так как он считается частью строки, ограниченной двумя кавычками.
-дальше выводится символы ${DATA}.Если бы в строковой константе перед $ не было бы escape-символа \, конструкция ${DATA} внутри строковой константы считалась бы ссылкой на переменную с именем DATA и была бы заменена ее значением.
	Хотя все данные в cmake имеют строковый тип, в некоторых слуаях строковые значения служат в качестве  данных другого типа.Так, строки используются для представляения чисел в десятичной записи-как целых, так и с плавающей точкой.
Формат записи аналогичен другим яп.
	При использовании управляющих конструкций необходим способ представления логических значений.Для этого могут быть использованы различные строковые значения
	
TRUE FALSE
YES NO
Y N
ON OFF
0 IGNORE NOTFOUND " "
	Запись всех именованных логических констант нечувствительна к регистру.Значения, заканчивающиеся на -NOTFOUND, можно использовать для проверки результатов успешност поиска файлов, библиотек и тд при помощи команд find_file(), find_library() и тд
которые записывают путь к найденному объекту в заданную переменную.Если поиск закончился неудачей, эти команды записывают в переменную ее имя, дополненное суффиксом -NOTFOUND.
	Другим типом данных, поддерживаемых языком cmake, является список.Списки представляются пр помощи обычных строк, внутри которых символы ; раделяют соседние элементы.Перебор элементов списка можно выполнять при помощи команд foreach() и endforeach().
При передаче списков в команды в качестве аргументов их элементы передаются внутрь команд несколькими аргументами вместо одного.Чтобы заставить команду воспринимать список как один аргумент, его можно поместить в двойные кавычки.
	пример 
message(a;b;c;)
message("a;b;c")
	вывод 
abc
a;b;c
	
	Здесь первая команда message() получит три аргумента a,b и c. Команда выводит свои аргументы друг за другом без пробелов.Вторая команда message() получит один аргумент строку a;b;c
	
	Переменные 
	Так же как и в языке burn shell и тд в cmake есть поддержка переменных строкового типа.Значения переменных могут использоваться внутри аргументов команд при помощи конструкции ${VAR_NAME}
	
	пример

set(GREETING Hello)
message("${GREETING} world!")
	
	Здесь переменной GREETING присваивается значение Hello, после чего выводится сообщение Hello world!
	Кроме пользовательских переменных в cmake также существует множество встроенных, имеющих специальное назначение.
	Имена переменных чувствительны к регистру и могут состоять почти из любых символов.
Замечание:при обработке проектов система cmake создает переменные с именами вида <имя_проекта>_SOURCE_DIR.Более свободные по сравнению с другими яп правила именования переменных позволяют накладывать 
ограничения на названия проектов.Например имя 01-hello_SOURCE_DIR является допустимым, хотя лексический анализиатор большенства яп мог бы воспринять его как арифметическое выражение
	Как и в других яп, переменные имеют облатсь действия.Области действия определяются следующими сущностями:
1.Ф-ция.Ф-ции cmake определяют пользовательские команды, которые могут использовать локальные перменные.Ф-ции определяются при помощи команд function() и endfunction()
2.Каталог (под)проекта.Каждый обрабатываемый каталог исходных файлов со своим описанием CMakeLists.txt задает собственную область действия переменных.Перед началом обработки подпроекта с собственным файлом 
CMakeLists.txt система CMake копирует в новую область все переменные из продительской области.Сценарии, запучскаемые cmake -P ... также задают область действия.
3.Кэш.Некоторые переменные могут быть определены в программе как предназначенные для постоянного хранения в файле CMakeLists.txt, записываемом  в выходной каталог.Эти переменные будут сохранять свои значения 
между повторными запусками cmake.Значения переменных можно редактировать,например, при помощи графической утилиты ccmake.Переменные кэша предназначены для хранения изменяемых настроек построения проекта.Первый запуск 
cmake заполняет их некоторыми значениями по умолчанию, последующие запуски 
Замечания:
-В отличие от подпроектов, подключаемых командой add_subdirectory(),модули cmake, которые подключаются командой include(), отдельной области действяи переменных не образуют
-Область действия также относится и к специальным переменным.То есть их значения и действие ограничиваются текущей областью.Таким образом, статус специальной переменной определяется ее именем.При этом в разных областях 
действия могут существовать разные специальные переменные с одним и тем же именем.
-переменные которые создаются в командной строке при выхове инструмента cmake с помощью ключа -D попдают в кэш
	При исполнении команд каждая найденная ссылка на переменную ${VAR_NAME} заменяется ее значением.Поиск значения выполняется от вершины в глубину стека областей действия переменных, образуемого динамически вложенными вызовами ф-ций.
Последней просматривается область действия текущего интерпритируемого файла CMakeLists.txt(если переменная не была найдена ранее), а после нее область кэша.Если переменная нигде не найдена, ссыдка на нее заменяется пустой строкой.
	Для установки значения переменных в cmake используется ряд команд 
	Специальная конструкция ENV{<имя переменной>} может быть использована для доступа к переменной окружения работающего процесса cmake.Она может использоваться везде, где можно применить обычные переменные(не кэша).Доступ к значению переменной 
окружения осуществляется пр помощи $ENV{<имя переменной>}
	пример 
set(ENV{PATH} "$ENV{PATH};${CMAKE_BINARY_DIR}")
	Здесь при помощи команды set() к переменной окружения PATH добавляется через точку с запятой путь к каталогу построения проекта верхнего уровня, который хранится в специальной переменной CMAKE_BINARY_DIR.Переменная окружения PATH в различных 
системах содержит список каталогов, в которых осуществляется поиск, в частности, исполняемых файлов при указании их имени в командной строке
Замечания:
-В разных системах пути в переменной окружения PATH могут отделяться друг от друга разными символами.В POSIX совместимых системах для этого используется двоеточие 
-Выполненное в примере выше изменение переменной окружения, унаследованной процессом cmake от родителя, будет действительно только для этого процесса на время его работы.Оно не повлияет на значение этой переменной для родительского процесса или процессов, которые
будут в дальнейшейм выполнять построение проекта.Чтобы установить значения переменных окружения для инструментов, которые запускаются во время исполнения правил, определяемых командами add_custom_target() и add_custom_command(),можно воспользоваться командой 
cmake -E env...
-cmake выдвигает те же требования к именам переменных окружения, что и для своих переменных.В частности, в именах переменных недопустимы скобки.Это затрудняет использование переменной окуржения ProgramFiles(x86), определенной в 64-битной системе 
	Свойства
Свойства аналогичны переменным, но относятся к различным объектам:
-каталогам проектов (как каталогам верхнего уровня, передаваемым cmake в качестве аргумента командной строки,так и подключаемым при помощи команды add_subdirectory().
-целям
-тестам
-исходным файлам
-переменным, хранящимся в кэше
-файлам для установки
	Также существуют глобальные свойства.Как и переменные, свойства могут быть стандартными(имеющими определенное назначение).Изменение таких свойств приводит к определенным изменениям в генерируемой системе построения.В дальнейшем стандартные свойства будут 
рассматриваться по мере необходимости.Некоторые стандартные свойства доступны только для чтения.Таким образом, можно провести аналогию между свойствами cmake и свойствами классов в ооп
	Для считывания и установки значений свойств используеются коанды get_property() и set_property()
Замечание:в отличие от переменных, которые имеют области действия, свойства всегда связаны с объектами, для которых они определены.Например, глобальное свойство с заданным  именем всегда существует в единственном экземпляре, в то время как одновременно может существовать 
сразу несколко переменных с одним именем а разных областях действия.
	Примеры построения простых проектов 
	Прежде чем приступать к изучению основных команд cmake, рассмотрим несколько примеров его использования 
Пример 
Пусть требуется построить проект из одного файла, в результате чего должен быть создан исполняемый модуль.Рассмотрим возможную структуру каталогов проекта на рисунке catalog_topology.png.Здесь в некоторой рабочей папке находятся каталог исходников(test_cmake) и каталог построения (build_catalog_for_test)
В этом примере оба каталога расположены рядом друг с другом для упрощения команды вызова cmake
	Для решения задачи в каталоге проекта должен содержаться файл CMakeLists.txt с содержимым которое находится ниже в картинке catalog_topology.png
Первая строка в этом файле является комментарием.Дальше следует команда project(), задающая имя проекта. Это имя будет использовано при создании системы построения в качестве имени решения или основного проекта
	Последняя строка содержит команду add_executable(), которая определяет новую цель построения с именем test_cmake и исходным файлом main.cpp.По умолчанию построение цели должно привести к созданию исполняемого файла с тем же именем, что и имя цели (test_cmake) в выходном каталоге проекта.
	Если в далнейшем необходимо добавить в проект другие исходники, их имена можно добавить в список аргументов команды add_executable().
Для удобства можно создать файл сценария build.cmd/build.sh рядом с каталогом build_catalog_for_test, при помощи которого можно автоматизировать процесс построения вызовом инструмента cmake с нужными аргами.Содержимое этого файла является специфичным для компьютера, на котором выполняется построение.
Пример 
Пусть необходимо построить проект содержащий две цели:статическую библиотеку и приложение которое использует эту библу.Файлы в каталоге проекта построены как в папке build2.
	Здесь исходные файлы библиотеки и приложения расположены в двух подкаталогах проектов нижнего уровня,каждый из которых имеет собственный файл описания CMakeLists.txt.Оба проекта объединяются третьим файлом CMakeLists.txt, расположенным на каталог выше, в корне составного проекта.Эти файлы могут иметь следующее содержание 
	Файл CMakeLists.txt верхнего уровня:

cmake_minimum_required(VERSION 2.8)
project(lib)
add_subdirectory(sample_lib)
add_subdirectory(sample_prog)

	Файл CMakeLists.txt проекта библиотеки:

add_library(sample_lib sample_mod.cpp sample_mod.h)

	Файл CMakeLists.txt проекта исполняемого файла:

add_executable(sample_prog main.cpp)
include_directories(../sample_lib)
target_link_libraries(sample_prog sample_lib)
	
	Описание проекта верхнего уровня начинается с команды cmake_minimum_required(), устанавливающей наименьшую версию инструмента CMake, которым может быть обработан проект.
Далее устанавливается название проекта пр помощи команды project().Затем к проекту присоединяются два проекта нижнего уровня пр помощи команд add_subdirectory(), задающих пути к подкаталогам.
	Описание проекта библиотеки содержит единственную команду add_library(), в которой задаются имя цкли и список исходных файлов проекта.Сборка проекта должна привести к созданию статической библы 
в выходном каталоге проекта sample_lib(подкаталога sample_lib выходного каталога проекта верзнего уровня).Имя файла библиотеки будет по умолчанию совпадать с именем цели sample_lib с префиксом и расширением,
зависящем от компилятора.Например для компилятора gcc имя библы будет libsample_lib.a.
	Описание проекта приложения отличается от предыдущего добавлением двух новых команд.Команда include_directories() определяет дополнительные пути поиска заголовочных файлов компилятором.В подкаталоге sample_lib 
находится заголовок sample_mod.h с описаниями, необходимыми для использования библиотеки.Исполнение команды include_directories() приводит к тому, что в генерируемом проекте команда для компляции исходных файлов проекта 
sample_prog будет содержать аргумент командной строки передающий компилятору путь к каталогу sample_lib.Например, для компилятора gcc это будет ключ -I с путем:
gcc ... -I<путь к sample_lib>...
	Таким образом, исходных файлах проекта приложения можно использовать следующую директиву:

#inlude "sample_mod.h"

вместо 

#include "../sample_lib/sample_mod.h"

	Наконец, команда target_link_libraries() определяет зависимость цели sample_prog от sample_lib.Кроме того, команда устанавливает, что при построении цели sample_prog будет использоваться библиотека, создаваемая в результате 
построения цели sample_lib.
	В заврешении осталось рассмотреть вопрос о том, каким образом можно указать системе cmake, что при построении цели sample_lib необходимо создать статическую библу, как требуется по условию.Дело в том, что по умолчанию команда add_library() может 
приводить к генерированию правил для создания динамической библы.Сборка цели в виде статической библы можно добиться тремя способами:
1.Можно при вызове cmake в cli определить значение специальной переменной BUILD_SHARED_LIBS как FALSE:
cmake -G "..." -D BUILD_SHARED_LIBS = 0 ../lib
	Здесь в качестве значения по умолчанию можно указать любую строку, означающую ложь.Таким образом, тип библы можно определить в cli
2.Если необходимо построение стстик библы в люом случае, можно упростить команду вызова cmake, выполнив нужное присваивание прямо в тексте описания проекта:
set(BUILD_SHARED_LIBS FALSE) 
	Эту команду можно вставить в файл CMakeLists.txt проекта верхнего уровня или проекта библы.Она повлияет на поведение всех команд add_library(), исполняемых после нее в текущей области действия переменной BUILD_SHARED_LIBS.
3.Наконец, тип библы можно указать приямо в команде add_library(), передав ей аргумент STATIC:

add_library(
sample_lib STATIC 
sample_mod.cpp
sample_mod.h)
	
	Эта настройка будет влиять только на данную цель.
	
	Команды общего назначения
	
	cmake_minimum_required()
cmake_minimum_required(VERSION <версия> [FATAL_ERROR])
	Команда определяет минимальную версию инструмента cmake, при помощи которого можно обрабатывать текущий входной файл проекта.Аргумент <версия> может содержать до 4 чисел, разделенных точками.
	Если версия cmake окажется ниже заданной, обработка файла остановится с сообщением об ошибке.
-Необязательный аргумент FATAL_ERROR имеет значение для версии cmake 2.4 или ниже-с ним команда приведет к останову с ошибкой вместо обычного рпедупреждения
	Команда в соответствии с номером версии также устанавливает политику совместимости-набор аспектов поведения cmake, делающий его совместимым с рпедыдущей версией.Множество аспектов поведения cmake может 
меняться от версии к версии.Явное указание политик совместимости желательно, поскольку обеспечивает корректную обработку описанний проектов при переходе на новую версию cmake.
	cmake_minimum_required() рекомендуется указывать самой первой в файле CMakeLists.txt верхнего уровня.Если команда еще не исполнялась и cmake требуется выполнить действие, зависящее от политики совместимости,
он выведет предупреждение.
	project()
	project(
		<имя проекта>
		[VERSION <версия>] [LANGUAGES <язык1>...<языкn>])
	Команда устанавливает имя для иерархии проектов.Например, для генераторов microsoft VS это имя определяет имя создаваемого решения
-После необязательного аргумента VERSION можно указать версию проекта-строку до 4 чисел, разделенных точками(по умолчанию ставится пустая строка).Установка версии проекта доступна начиная с cmake 3.0
-После необязательного аргумента LANGUAGES указываются яп, для которых обеспечивается поддержка в проекте.По умолчанию установлен c/с++.Если после арга LANGUAGES добавить NONE, поддержка всех языков будет отключена.
Если в project() не определена версия проекта, аргумент LANGUAGES можно пропустить.Передача арга LANGUAGES доступна в cmake 3.0+
	Команда устанавливает значения нескольким специальным переменным CMake
	Некоторые переменные, устанавливаемые командой project)(
	имя переменной 					значение 
	PROJECT_NAME					имя проекта, определяемое командой
	PROJECT_SOURCE_DIR				полный путь к каталогу проекта верхнего уровня(каталог исходников)
	<имя проекта>_SOURCE_DIR		то же самое
	PROJECT_BINARY_DIR				полный путь к каталогу построения верхнего уровня(каталог выходных и промежуточных файлов)
	<имя проекта>_BINERY_DIR		то же самое
	PROJECT_VERSION					версия проекта, указанная после VERSION
	<имя проекта>_VERSION			то же самое
	Команду project() рекомендуется указывать в файле CMakeLists.txt верхнего уровня.Она должна быть указана в явном виде(не внутри модулей подключаемых include()).
Если ее там нет, система создает проект с некоторым именем по умолчанию.Внутри файлов CMakeLists.txt для подпроектов эту команду имеет смысл указывать, если эти проекты вместе с проектами, от которых для них установлены 
зависимости, могут собираться отдельно от остального набора проектов.В этом случае для подпроектов будут сгенерированы отдельные решения, которые будут обрабатываться интегрированной средой гораздо быстрее полного набора(обычно при открытии решений 
иде собирает инфу обо всех исходных файлах с целью построения информации для быстрого перехода и тд)
	include()
	include(
	<файл> | <модуль>
	[OPTIONAL] [RESULT_VARIBLE <имя переменной>])
	Загружает из внешнего файла и исполняет заданный модуль cmake.Модуль может задаваться при помощи пути к файлу(включая расширение .cmake, относительный путь определяет местонахождение относительно каталога проекта) либо только именем модуля(без пути и расширения).
В последнем случае файл с именем <модуль>.cmake ищется в каталогах, список которых задан в переменной CMAKE_MODULE_PATH(по умолчанию пустая), и затем в каталоге стандартных модулей, поставляемых с cmake.
-если указан необязательный арг OPTIONAL, исполнение команды include() не приведет к ошибке, если указанный модуль не будет найден.Это может быть полезным в тех случаях, когда какие-то необязательные для построения компоненты проекта не восстанавливаются из репозитория
исходных кодов и не собираются в целых экономии времени
-после RESULT_VARIBLE можно указать имя переменной, в которую будет записан полный путь к найденному модулю или значение NOTFOUND, если модуль не будет найден.Таким образом, можно программно проконтролировать успешность загрузки модуля

