	Основы языка cmake
	Основые концепции 
	Генераторы 
	Генераторами называются компоненты cmake, отвечающие за создание проектов для конечных систем построения.Для каждой поддерживаемой 
системы (make, visual studio) существует свой генератор.Выбор конкретного генератора задается в cli cmake при помощи ключа -G, например:
cmake -G "Visual Studio 14 2015" ..\project_src
	Здесь последний аргумент ..\project_src указывает утилите cmake с интерфейсом cli путь к катологу проекта.Текущий каталог, откуда запускает 
программа cmake, будет каталогом построеня, в котором будут сгенерированы файлы проектов.
	Реализация cmake для различных платформ могут поддерживтаь разные наборы генераторов для данной версии можно узнать при помощи команды:
cmake --help
	Кроме этого,некоторые генераторы поддерживают различные варанты в виде наборов инструментов(ключ -T) и платформ (ключ -A). Для совместимости 
с предыдущими версиями инструмента cmake возможно указание платформы в названии генератора.Например:
cmake -G "visual studio 11 2012" -A ARM ..\project_src
cmake -G "visual studio 11 2012 ARM" ..\project_src
или 
cmake -G "visual studio 11 2012" -A X64 ..\project_src
cmake -G "visual studio 11 2012 Win64" ..\project_src
	При отсутствии ключа -G к cli cmake выбирается некоторый генератор по умолчанию для данной платформы
	В именах генераторов для visual studio c++ можно опускать номер года.Например
cmake -G "visual studio 11 2012 Win64" ..\project_src
	Входные файлы
	Входными файлами на языке cmake являются файлы CMakeLists.txt, лежащие в корне каталога проекта(со всеми исходниками).Путь к катологу проекта передается 
в cli в качестве последнего аргумента.Круаные проекты могут также содержать подкаталоги с проектаим нижнего уровня, каждый из которых будет иметь в корне свой 
CMakeLists.txt файл.Каталоги с подпроектами подключаются из файла на языке cmake при попощи команды add_subdirectory().Для каждого обрабатываемого файла CMakeLists.txt 
система cmake создает в выходном каталоге подкаталог, служащий по умолчанию каталогом для промежуточных и выходных файлов этого (под)проекта, генерируя в нем все 
необходимые файлы для используемоый конечной системы построеня.
	Кроме файлов CMakeLists.txt также могут использоваться файлы с расширением .make.Эти файлы могут подключаться из программы на языке cmake при помощи директивы include(),
вызываться при исполнении команды find_package() или передаваться инструменту cmake для исполнения при помощи ключа командной строки -P.При исполнении этих файлов система cmake не создает 
отдельных выходных каталогов и не генерирует файлов для построения.
	В процессе генерирования файлов описания проектов cmake определяет в них зависимости от входных файлов.Изменения в них приведут при запуске построения конечной системой к повторному 
вызову инструмента cmake, который перегенерирует описания проектов.Таким образом, автоматически отслеживаются ситуации изменения входных файлов cmake.
	Пути 
	Следует обратить внимание на то что система cmake использует абсолютные пути везде где это возможно.В генерируемых файлах проектов для конечных систем построения содержатся абсолютные пути 
к исходным, промежуточным и конечным файлам.Определяемые пользователем пути поиска заголовочных файлов при генерировании преобразутся в абсолютные и тд.Специальные переменные, хранящие пути к файлам 
и каталогам(такие как CMAKE_SOURCE_DIR), содержат абсолютные пути.На платформах, файловые системы которых нечувствительны к регистру имен файлов, символы путей преобразуются к тому регистру, в котором 
они хранятся в системе.
	Такой подход ускоряет и упрощает процесс генерирования файлов для конечных систем построения.Например, для проверки того , указывают ли два пути на один и тот же файл или каталог, достаточно проверить 
эти строки на равенство.Кроме этого, генерируемые файлы реализуют требуемые от них ф-ции построения более надежным образом.Например,в make-файле указываются абсолютные пути к вызываемым инструментам, что делает 
процесс построения независимым от значения переменной окружения PATH и других общесистемных настроек.
	Однако исользование абсолютных путей также накладывает на разработчика определенные обязательства.Так , при перемещении каталога проекта или каталога построения в файловой системе приходится заново генерировать 
файлы повтроным запуском cmake.Понимание принципа использования абсолютных путей позволяет избежать многих типичных ошибок при использовании cmake в качестве системы построения проекта.
	Синтаксис
	Команды
	Программа на cmake состоит из последовательности команд, исполняемых интерпритатором.Синтаксис команды:
	<имя команды>([<аргумент1>...<аргумент2>])
	Замечание:аргументы команд разделяются символами-разделителями, а не запятыми.
	В качестве символа-разделителя могут использоваться один или несколько пробелов, символ табуляции и перевода строки.Таким образом, в отличие от make, qmake и тд при записи длинной команды в несколько строк
не нужно завершать каждую из них символом \.
	Языком поддерживаются однострочные комменты, начинаюзиеся с символа #.Также, начиная с cmake 3.0, поддерживаются блочные комменты между символами #[[ и ]]
	Команды являются единственным средством в языке, при помощи них, например, записываются все управляющие конструкции
	
if(WIN32)
	message(STATUS "Building for windows")
endif()

Замечание:все инструкции, включая endif() в примере выше, являются командами, поэтому после них необходимо ставить скобки.
	Как правило,команды поддерживают переменное количество аргументов
	Строки
	Аргументами команд являются строки.Как и в языках make и тд строки-это последовательности символови escape-последовательностей.Чтобы включить в строку символ-разделитель, можно заключить ее в двойные кавычки.В этом случае 
интерпритатор будет считать данне символы частью строки, а не разделителем аргументов.Строки в кавычках могут занимать несколько строк в тексте программы, при этом символ \ в конце строки текста приводит к тому что следующий за ним 
символ перевода строки не будет считаться частью строки.
	Пример 
message(
	"AB\nCD
	\tEF\
	GH \${DATA}\"\\#"
	)
выведет на консоль:
AB
CD
	EF GH ${DATA}"\#

-Команда выполняет первый перевод строки после символов AB, так как в строковой константе после них указан escape-символ \n
-следующий перевод строки после CD указан в строке явно
-следующая строка начинается с \t, символ перевода строки после EF подавляется символов \ в конце строки.Таким образом,после символа EF на печать выводится два пробела и смиволы GH
-за символами GH выводится пробел, так как он считается частью строки, ограниченной двумя кавычками.
-дальше выводится символы ${DATA}.Если бы в строковой константе перед $ не было бы escape-символа \, конструкция ${DATA} внутри строковой константы считалась бы ссылкой на переменную с именем DATA и была бы заменена ее значением.
	Хотя все данные в cmake имеют строковый тип, в некоторых слуаях строковые значения служат в качестве  данных другого типа.Так, строки используются для представляения чисел в десятичной записи-как целых, так и с плавающей точкой.
Формат записи аналогичен другим яп.
	При использовании управляющих конструкций необходим способ представления логических значений.Для этого могут быть использованы различные строковые значения
	
TRUE FALSE
YES NO
Y N
ON OFF
0 IGNORE NOTFOUND " "
	Запись всех именованных логических констант нечувствительна к регистру.Значения, заканчивающиеся на -NOTFOUND, можно использовать для проверки результатов успешност поиска файлов, библиотек и тд при помощи команд find_file(), find_library() и тд
которые записывают путь к найденному объекту в заданную переменную.Если поиск закончился неудачей, эти команды записывают в переменную ее имя, дополненное суффиксом -NOTFOUND.
	Другим типом данных, поддерживаемых языком cmake, является список.Списки представляются пр помощи обычных строк, внутри которых символы ; раделяют соседние элементы.Перебор элементов списка можно выполнять при помощи команд foreach() и endforeach().
При передаче списков в команды в качестве аргументов их элементы передаются внутрь команд несколькими аргументами вместо одного.Чтобы заставить команду воспринимать список как один аргумент, его можно поместить в двойные кавычки.
	пример 
message(a;b;c;)
message("a;b;c")
	вывод 
abc
a;b;c
	
	Здесь первая команда message() получит три аргумента a,b и c. Команда выводит свои аргументы друг за другом без пробелов.Вторая команда message() получит один аргумент строку a;b;c
	
	Переменные 
	Так же как и в языке burn shell и тд в cmake есть поддержка переменных строкового типа.Значения переменных могут использоваться внутри аргументов команд при помощи конструкции ${VAR_NAME}
	
	пример

set(GREETING Hello)
message("${GREETING} world!")
	
	Здесь переменной GREETING присваивается значение Hello, после чего выводится сообщение Hello world!
	Кроме пользовательских переменных в cmake также существует множество встроенных, имеющих специальное назначение.
	Имена переменных чувствительны к регистру и могут состоять почти из любых символов.
Замечание:при обработке проектов система cmake создает переменные с именами вида <имя_проекта>_SOURCE_DIR.Более свободные по сравнению с другими яп правила именования переменных позволяют накладывать 
ограничения на названия проектов.Например имя 01-hello_SOURCE_DIR является допустимым, хотя лексический анализиатор большенства яп мог бы воспринять его как арифметическое выражение
	Как и в других яп, переменные имеют облатсь действия.Области действия определяются следующими сущностями:
1.Ф-ция.Ф-ции cmake определяют пользовательские команды, которые могут использовать локальные перменные.Ф-ции определяются при помощи команд function() и endfunction()
2.Каталог (под)проекта.Каждый обрабатываемый каталог исходных файлов со своим описанием CMakeLists.txt задает собственную область действия переменных.Перед началом обработки подпроекта с собственным файлом 
CMakeLists.txt система CMake копирует в новую область все переменные из продительской области.Сценарии, запучскаемые cmake -P ... также задают область действия.
3.Кэш.Некоторые переменные могут быть определены в программе как предназначенные для постоянного хранения в файле CMakeLists.txt, записываемом  в выходной каталог.Эти переменные будут сохранять свои значения 
между повторными запусками cmake.Значения переменных можно редактировать,например, при помощи графической утилиты ccmake.Переменные кэша предназначены для хранения изменяемых настроек построения проекта.Первый запуск 
cmake заполняет их некоторыми значениями по умолчанию, последующие запуски 
Замечания:
-В отличие от подпроектов, подключаемых командой add_subdirectory(),модули cmake, которые подключаются командой include(), отдельной области действяи переменных не образуют
-Область действия также относится и к специальным переменным.То есть их значения и действие ограничиваются текущей областью.Таким образом, статус специальной переменной определяется ее именем.При этом в разных областях 
действия могут существовать разные специальные переменные с одним и тем же именем.
-переменные которые создаются в командной строке при выхове инструмента cmake с помощью ключа -D попдают в кэш
	При исполнении команд каждая найденная ссылка на переменную ${VAR_NAME} заменяется ее значением.Поиск значения выполняется от вершины в глубину стека областей действия переменных, образуемого динамически вложенными вызовами ф-ций.
Последней просматривается область действия текущего интерпритируемого файла CMakeLists.txt(если переменная не была найдена ранее), а после нее область кэша.Если переменная нигде не найдена, ссыдка на нее заменяется пустой строкой.
	Для установки значения переменных в cmake используется ряд команд 
	Специальная конструкция ENV{<имя переменной>} может быть использована для доступа к переменной окружения работающего процесса cmake.Она может использоваться везде, где можно применить обычные переменные(не кэша).Доступ к значению переменной 
окружения осуществляется пр помощи $ENV{<имя переменной>}
	пример 
set(ENV{PATH} "$ENV{PATH};${CMAKE_BINARY_DIR}")
	Здесь при помощи команды set() к переменной окружения PATH добавляется через точку с запятой путь к каталогу построения проекта верхнего уровня, который хранится в специальной переменной CMAKE_BINARY_DIR.Переменная окружения PATH в различных 
системах содержит список каталогов, в которых осуществляется поиск, в частности, исполняемых файлов при указании их имени в командной строке
Замечания:
-В разных системах пути в переменной окружения PATH могут отделяться друг от друга разными символами.В POSIX совместимых системах для этого используется двоеточие 
-Выполненное в примере выше изменение переменной окружения, унаследованной процессом cmake от родителя, будет действительно только для этого процесса на время его работы.Оно не повлияет на значение этой переменной для родительского процесса или процессов, которые
будут в дальнейшейм выполнять построение проекта.Чтобы установить значения переменных окружения для инструментов, которые запускаются во время исполнения правил, определяемых командами add_custom_target() и add_custom_command(),можно воспользоваться командой 
cmake -E env...
-cmake выдвигает те же требования к именам переменных окружения, что и для своих переменных.В частности, в именах переменных недопустимы скобки.Это затрудняет использование переменной окуржения ProgramFiles(x86), определенной в 64-битной системе 
	Свойства
Свойства аналогичны переменным, но относятся к различным объектам:
-каталогам проектов (как каталогам верхнего уровня, передаваемым cmake в качестве аргумента командной строки,так и подключаемым при помощи команды add_subdirectory().
-целям
-тестам
-исходным файлам
-переменным, хранящимся в кэше
-файлам для установки
	Также существуют глобальные свойства.Как и переменные, свойства могут быть стандартными(имеющими определенное назначение).Изменение таких свойств приводит к определенным изменениям в генерируемой системе построения.В дальнейшем стандартные свойства будут 
рассматриваться по мере необходимости.Некоторые стандартные свойства доступны только для чтения.Таким образом, можно провести аналогию между свойствами cmake и свойствами классов в ооп
	Для считывания и установки значений свойств используеются коанды get_property() и set_property()
Замечание:в отличие от переменных, которые имеют области действия, свойства всегда связаны с объектами, для которых они определены.Например, глобальное свойство с заданным  именем всегда существует в единственном экземпляре, в то время как одновременно может существовать 
сразу несколко переменных с одним именем а разных областях действия.
	Примеры построения простых проектов 
	Прежде чем приступать к изучению основных команд cmake, рассмотрим несколько примеров его использования 
Пример 
Пусть требуется построить проект из одного файла, в результате чего должен быть создан исполняемый модуль.Рассмотрим возможную структуру каталогов проекта на рисунке catalog_topology.png.Здесь в некоторой рабочей папке находятся каталог исходников(test_cmake) и каталог построения (build_catalog_for_test)
В этом примере оба каталога расположены рядом друг с другом для упрощения команды вызова cmake
	Для решения задачи в каталоге проекта должен содержаться файл CMakeLists.txt с содержимым которое находится ниже в картинке catalog_topology.png
Первая строка в этом файле является комментарием.Дальше следует команда project(), задающая имя проекта. Это имя будет использовано при создании системы построения в качестве имени решения или основного проекта
	Последняя строка содержит команду add_executable(), которая определяет новую цель построения с именем test_cmake и исходным файлом main.cpp.По умолчанию построение цели должно привести к созданию исполняемого файла с тем же именем, что и имя цели (test_cmake) в выходном каталоге проекта.
	Если в далнейшем необходимо добавить в проект другие исходники, их имена можно добавить в список аргументов команды add_executable().
Для удобства можно создать файл сценария build.cmd/build.sh рядом с каталогом build_catalog_for_test, при помощи которого можно автоматизировать процесс построения вызовом инструмента cmake с нужными аргами.Содержимое этого файла является специфичным для компьютера, на котором выполняется построение.
Пример 
Пусть необходимо построить проект содержащий две цели:статическую библиотеку и приложение которое использует эту библу.Файлы в каталоге проекта построены как в папке build2.
	Здесь исходные файлы библиотеки и приложения расположены в двух подкаталогах проектов нижнего уровня,каждый из которых имеет собственный файл описания CMakeLists.txt.Оба проекта объединяются третьим файлом CMakeLists.txt, расположенным на каталог выше, в корне составного проекта.Эти файлы могут иметь следующее содержание 
	Файл CMakeLists.txt верхнего уровня:

cmake_minimum_required(VERSION 2.8)
project(lib)
add_subdirectory(sample_lib)
add_subdirectory(sample_prog)

	Файл CMakeLists.txt проекта библиотеки:

add_library(sample_lib sample_mod.cpp sample_mod.h)

	Файл CMakeLists.txt проекта исполняемого файла:

add_executable(sample_prog main.cpp)
include_directories(../sample_lib)
target_link_libraries(sample_prog sample_lib)
	
	Описание проекта верхнего уровня начинается с команды cmake_minimum_required(), устанавливающей наименьшую версию инструмента CMake, которым может быть обработан проект.
Далее устанавливается название проекта пр помощи команды project().Затем к проекту присоединяются два проекта нижнего уровня пр помощи команд add_subdirectory(), задающих пути к подкаталогам.
	Описание проекта библиотеки содержит единственную команду add_library(), в которой задаются имя цкли и список исходных файлов проекта.Сборка проекта должна привести к созданию статической библы 
в выходном каталоге проекта sample_lib(подкаталога sample_lib выходного каталога проекта верзнего уровня).Имя файла библиотеки будет по умолчанию совпадать с именем цели sample_lib с префиксом и расширением,
зависящем от компилятора.Например для компилятора gcc имя библы будет libsample_lib.a.
	Описание проекта приложения отличается от предыдущего добавлением двух новых команд.Команда include_directories() определяет дополнительные пути поиска заголовочных файлов компилятором.В подкаталоге sample_lib 
находится заголовок sample_mod.h с описаниями, необходимыми для использования библиотеки.Исполнение команды include_directories() приводит к тому, что в генерируемом проекте команда для компляции исходных файлов проекта 
sample_prog будет содержать аргумент командной строки передающий компилятору путь к каталогу sample_lib.Например, для компилятора gcc это будет ключ -I с путем:
gcc ... -I<путь к sample_lib>...
	Таким образом, исходных файлах проекта приложения можно использовать следующую директиву:

#inlude "sample_mod.h"

вместо 

#include "../sample_lib/sample_mod.h"

	Наконец, команда target_link_libraries() определяет зависимость цели sample_prog от sample_lib.Кроме того, команда устанавливает, что при построении цели sample_prog будет использоваться библиотека, создаваемая в результате 
построения цели sample_lib.
	В заврешении осталось рассмотреть вопрос о том, каким образом можно указать системе cmake, что при построении цели sample_lib необходимо создать статическую библу, как требуется по условию.Дело в том, что по умолчанию команда add_library() может 
приводить к генерированию правил для создания динамической библы.Сборка цели в виде статической библы можно добиться тремя способами:
1.Можно при вызове cmake в cli определить значение специальной переменной BUILD_SHARED_LIBS как FALSE:
cmake -G "..." -D BUILD_SHARED_LIBS = 0 ../lib
	Здесь в качестве значения по умолчанию можно указать любую строку, означающую ложь.Таким образом, тип библы можно определить в cli
2.Если необходимо построение стстик библы в люом случае, можно упростить команду вызова cmake, выполнив нужное присваивание прямо в тексте описания проекта:
set(BUILD_SHARED_LIBS FALSE) 
	Эту команду можно вставить в файл CMakeLists.txt проекта верхнего уровня или проекта библы.Она повлияет на поведение всех команд add_library(), исполняемых после нее в текущей области действия переменной BUILD_SHARED_LIBS.
3.Наконец, тип библы можно указать приямо в команде add_library(), передав ей аргумент STATIC:

add_library(
sample_lib STATIC 
sample_mod.cpp
sample_mod.h)
	
	Эта настройка будет влиять только на данную цель.
	
	Команды общего назначения
	
	cmake_minimum_required()
cmake_minimum_required(VERSION <версия> [FATAL_ERROR])
	Команда определяет минимальную версию инструмента cmake, при помощи которого можно обрабатывать текущий входной файл проекта.Аргумент <версия> может содержать до 4 чисел, разделенных точками.
	Если версия cmake окажется ниже заданной, обработка файла остановится с сообщением об ошибке.
-Необязательный аргумент FATAL_ERROR имеет значение для версии cmake 2.4 или ниже-с ним команда приведет к останову с ошибкой вместо обычного рпедупреждения
	Команда в соответствии с номером версии также устанавливает политику совместимости-набор аспектов поведения cmake, делающий его совместимым с рпедыдущей версией.Множество аспектов поведения cmake может 
меняться от версии к версии.Явное указание политик совместимости желательно, поскольку обеспечивает корректную обработку описанний проектов при переходе на новую версию cmake.
	cmake_minimum_required() рекомендуется указывать самой первой в файле CMakeLists.txt верхнего уровня.Если команда еще не исполнялась и cmake требуется выполнить действие, зависящее от политики совместимости,
он выведет предупреждение.
	project()
	project(
		<имя проекта>
		[VERSION <версия>] [LANGUAGES <язык1>...<языкn>])
	Команда устанавливает имя для иерархии проектов.Например, для генераторов microsoft VS это имя определяет имя создаваемого решения
-После необязательного аргумента VERSION можно указать версию проекта-строку до 4 чисел, разделенных точками(по умолчанию ставится пустая строка).Установка версии проекта доступна начиная с cmake 3.0
-После необязательного аргумента LANGUAGES указываются яп, для которых обеспечивается поддержка в проекте.По умолчанию установлен c/с++.Если после арга LANGUAGES добавить NONE, поддержка всех языков будет отключена.
Если в project() не определена версия проекта, аргумент LANGUAGES можно пропустить.Передача арга LANGUAGES доступна в cmake 3.0+
	Команда устанавливает значения нескольким специальным переменным CMake
	Некоторые переменные, устанавливаемые командой project)(
	имя переменной 					значение 
	PROJECT_NAME					имя проекта, определяемое командой
	PROJECT_SOURCE_DIR				полный путь к каталогу проекта верхнего уровня(каталог исходников)
	<имя проекта>_SOURCE_DIR		то же самое
	PROJECT_BINARY_DIR				полный путь к каталогу построения верхнего уровня(каталог выходных и промежуточных файлов)
	<имя проекта>_BINERY_DIR		то же самое
	PROJECT_VERSION					версия проекта, указанная после VERSION
	<имя проекта>_VERSION			то же самое
	Команду project() рекомендуется указывать в файле CMakeLists.txt верхнего уровня.Она должна быть указана в явном виде(не внутри модулей подключаемых include()).
Если ее там нет, система создает проект с некоторым именем по умолчанию.Внутри файлов CMakeLists.txt для подпроектов эту команду имеет смысл указывать, если эти проекты вместе с проектами, от которых для них установлены 
зависимости, могут собираться отдельно от остального набора проектов.В этом случае для подпроектов будут сгенерированы отдельные решения, которые будут обрабатываться интегрированной средой гораздо быстрее полного набора(обычно при открытии решений 
иде собирает инфу обо всех исходных файлах с целью построения информации для быстрого перехода и тд)
	include()
	include(
	<файл> | <модуль>
	[OPTIONAL] [RESULT_VARIBLE <имя переменной>])
	Загружает из внешнего файла и исполняет заданный модуль cmake.Модуль может задаваться при помощи пути к файлу(включая расширение .cmake, относительный путь определяет местонахождение относительно каталога проекта) либо только именем модуля(без пути и расширения).
В последнем случае файл с именем <модуль>.cmake ищется в каталогах, список которых задан в переменной CMAKE_MODULE_PATH(по умолчанию пустая), и затем в каталоге стандартных модулей, поставляемых с cmake.
-если указан необязательный арг OPTIONAL, исполнение команды include() не приведет к ошибке, если указанный модуль не будет найден.Это может быть полезным в тех случаях, когда какие-то необязательные для построения компоненты проекта не восстанавливаются из репозитория
исходных кодов и не собираются в целых экономии времени
-после RESULT_VARIBLE можно указать имя переменной, в которую будет записан полный путь к найденному модулю или значение NOTFOUND, если модуль не будет найден.Таким образом, можно программно проконтролировать успешность загрузки модуля
	message()
	message([<режим>] <строка1>...<строка2>)
<режим>::= STATUS|WARNING|AUTHOR_WARNING|SEND_ERROR|FATAL_ERROR|DEPRICATION
	Команда предназначена для вывода сообщения различными утилитами cmake, интерпритирующими входной файл.Консольная программа cmake выводти сообщение в стандартный поток вывода при использовании режима STATUS и в стандартный поток ошибок а остальных случаях.Другие утилиты 
выводят сообщения в окно журнала, в виде диалоговых окон и тд.
	Выводимое сообщение получается в резульатате конкатенации строк, передаваемых команде
-При помощи первого арга можно указать режим, который влияет на способ отображения сообщения, способ его форматирования, а также дальнейшее поведение cmake.Он может продолжить или прервать обработку входного файла, а также выполнить или пропустить генерацию файлов для конечной системы построения
	режимы выполнения команды message()
режим 				описание 							обработка	генерация
не указан			важная инфа							+			+
STATUS 				обычная инфа						+			+
WARNING 			предупреждение						+			+			
AUTHOR_WARNING 		предупреждение для разраба			+			+
SEND_ERROR			локальная ошибка					+			-
FATAL_ERROR			серьезная ошибка					-			-
DEPRICATION			использование устарешвей фишки		зависит от настроек
	При исполнении команды message(DEPRICATION...) поведение cmake зависит от значений специальных переменных CMAKE_ERROR_DEPRECATED И CMAKE_WARN_DEPRECATED.Если первая из них содержит значение истина, поведение аналогично режиму FATAL_ERROR, иначе, если  вторая содержит значений истина-режим WARNING.
Иначе обработка файла и генерация продложаются, и сообщение не выводится.По умолчанию обе переменные содержат значение FALSE
	Команды описания целей
	add_executable()
	add_executable(
	<логическое имя цели>
	[WIN32][MACOSX_BUILD][EXCLUDE_FROM_ALL]
	<исходный модуль1>...<исходный модульn>)
	Команда добавляет к проекту цель с заданным логическим именем, построение которой из уникальных исходных модулей должно привести к созданию исполняемого файла
	Имя исполняемого файла формируется из имени цели и расширения.Изменить имя можно также при помощи установки свойства OUTPUT_NAME цели
	По умолчанию файл должен в подкаталоге построения, соответствующем текущему обрабатываемому подкаталогу проекта.Изменить этот каталог можно при помощи установки соответствующего свойства цели, которое изначально инициализируется значением специальной переменной CMAKE_RUNTIME_OUTPUT_DIRECTORY.Конечные 
системы построения, которые поддерживают множественные конфигурации,могут добавлять к этому пути еще один вложенный каталог, соответствующий имени используемой конфигурации
-передача команде необязательного аргумента WIN32 приводит к точу, что при построении для windows приложение не будет иметь создаваемой по умолчанию консоли, даже если главной ф-цией программы является ф-ция main(), а не Winmain().Это достигается передачей компоновщику аргумента cli, зависящего от компилятора.
Например, для системы gcc-MinGW компоновщику передается ключ -Wl, --subsystem, windows.Это бывает удобно, в чатсности для разработки с использованием QT.
	При использовании арга WIN32 можно обойтись без ф-ции Winmain(), таким образом, упростить переносимость кода.Для остальных платформ этот арг игнорируется.
-передача MACOSX_BUILD сообщит системе cmake, что создваемый исполняемый файл должен быть пакетом приложения системы OSX
-передача EXCLUDE_FROM_ALL приводит к тому что генерируемая цель будет исключена из цели all.Таким образом, например, при работе с системой make команда make или make all приведет к построению данной цели, только если от нее зависимы другие цели, включенные в all
Замечание: при использовании компилятора visual c++ передачи аргумента WIN32 команде add_executable() недостаточно, если требуется использовать ф-цию main() в качестве точки входа.В этом случае также требуется передача компоновщику ключа 
/ENTRY:mainCRTSartup
	add_library()
1.	add_library(
	<логическое имя цели>
	[STATIC|SHARED|MODULE]
	[EXCLUDE_FROM_ALL]
	<исходный модуль1>...<исходный модульn>)

2.	add_library(
	<логическое имя цели>
	<тип библы>
	IMPORTED)
	<тип библы>::=SHARED|STATIC|MODULE|UNKNOWN
	
	Первая форма команды add_executable(), но создает цель для построения библы
	Имя библы будет сформировано из базового имени(по умолчанию соответствующего имени цели):например <имя>.lib для visual c++, lib<имя>.a для gcc и тд
	По умолчанию библа будет создана в подкаталоге построения, соответствующем текущему обрабатываемому подкаталогу проекта.Изменить расположение библы можно при помощи установки свойств цели, которые инициализируется значениями специальных переменных.
Как и в случае с командой add_executable(), конечные системы построения могут добавлять к этим поутям каталог с именем используемой конфигурации
	специальные переменные, определяющие выходные каталоги для библа
переменная 								виды библ
CMAKE_ARCHIVE_OUTPUT_DIRECTORY			статик(+импорта)
CMAKE_RUNTIME_OUTPUT_DIRECTORY			DLL
CMAKE_LIBRARY_OUTPUT_DIRECTORY			модули, разделяемые 
-типа библ можно задачать пр помощи необязательного арга:
	1.STATIC:статическая
	2.SHARED:динамическая
	3.MODULE: разделяемая, предназначенная исключительно для загрузки при помощи ф-ций api(pisix dlopen() и тд).Такой тип библ испольуется для реализации загружаемых модулей
	По умолчанию создаются правила для построения разделяемой библы,если переменная BUILD_SHARED_LIBS содержит истинное значение,  и статик, если иначе 
	Таблица выше нуждается в пояснении.При построении все статические библы помещаются в каталог, определяемый переменной CMAKE_ARCHIVE_OUTPUT_DIRECTORY.Аналогично, все загружаемые модули попадают в каталог, путь к которому задается переменной CMAKE_LIBRARY_OUTPUT_DIRECTORY.
Сложнее с разделяемыми библиотеками.Дело в том что posix-совместимых системах разделяемые библы принято помещать в специальные каталоги-туде же, где находятся и статические библы.При создании 
процесса динамический загрузчик исполняемого файла будет искать все требуемые для него библы в этих каталогах.Некоторые из этих путей могут быть заданы системной переменной (переменной окружения LD_LIBRARY_PATH).Другие из этих путей могут храниться в относительном виде в самом 
исполняемом файле.Если библы будут расположены в другом месте, загрузчик не сможет их найти.Как правило, исполняемые файлы помещаются в каталог с именем bin, а разделяемые библы -в каталог рядом lib.Таким образом, разделяемые библы помещаются при построении в каталог, путь к которому 
задается переменной CMAKE_LIBRARY_OUTPUT_DIRECTORY.
	В системах совместимых с windows динамические библы ищутся загрузчиком прежде всего в тех же каталогах что и исполняемые файлы.Например, динамическая библа может находиться в том же каталоге что и использующая ее программа.По этой причине динамические библы создаются при построении 
проекта в таких системах в том же каталоге что и исполняемые модули то есть путь которому находтися в переменной CMAKE_RUNTIME_OUTPUT_DIRECTORY.При этом для облегчения процесса подключения дин библы к использующему ее приложению при ее построении также создается небольшая статическая библа,
содержащая инфу об экспортируемых символах динамической.Как и другие статические библы, библа импорта помещается в каталог путь к которой определяется переменной CMAKE_ARCHIVE_OUTPUT_DIRECTORY.
	Пример в build3
Пусть проект включает исполняемый файл и две библы, соторые он использует.Пусть структура проекта соответствует картинке build3.png
	В этом случае для формирования при построении системы выходных файлов каталогов, совместимой с рекомендациями GNU, можно использовать описание которое дано в описани проекта в каталоге верхнего уровня
	Здесь специальная переменная CMAKE_BINARY_DIR хранит полный путь к каталогу построения проекта верхнего уровня.Вместо нее в этом примере можно использовать переменную CMAKE_CURRENT_BINARY_DIR, в котрой хранится путь к каталогу построения текущего (под)проекта
	В результате обработки этого примера cmake и сборки проекта в windows каталог построения будет иметь структуру как на картинке buil3win.png, а в posix-совместимых системах как на картинке build3pos.png.Как можно видеть,в системе windows все выходные файлы будут помещены в один каталог, так что 
при отладке приложения загрузчки сможет найти все требуемые ему библы.То же самое будет справедливо и для posix-систем.
	Вторая форма команды add_library() предназначена для добавления к проекту внешней заранее собранной библы (как правило стронней).Как и для предыдущей формы команды, создается цель с заданным логическим именем, которая по умолчанию имеет область видимости текущего каталога построения и ниже и которую 
можно использовать как и остальные цели библиотек, для связывания с другими целями проекта при помощи команды target_link_libraries().Однако в этом случае не создается никаких правил построения библы.Чтобы указать меcтоположение файла библы для создаваемой цели, необходимо записать его в свойство цели IMPORTED_LOCATION, 
а также в свойства IMPORTED_LOCATION_DEBUG и тд для каждой используемой конфигурации при помощи set_property().Для получения пути к исполняемому файлу библы можно использовать команду find_library()