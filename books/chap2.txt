	Основы языка cmake
	Основые концепции
	Генераторы
	Генераторами называются компоненты cmake, отвечающие за создание проектов для конечных систем построения.Для каждой поддерживаемой
системы (make, visual studio) существует свой генератор.Выбор конкретного генератора задается в cli cmake при помощи ключа -G, например:
cmake -G "Visual Studio 14 2015" ..\project_src
	Здесь последний аргумент ..\project_src указывает утилите cmake с интерфейсом cli путь к катологу проекта.Текущий каталог, откуда запускает
программа cmake, будет каталогом построеня, в котором будут сгенерированы файлы проектов.
	Реализация cmake для различных платформ могут поддерживтаь разные наборы генераторов для данной версии можно узнать при помощи команды:
cmake --help
	Кроме этого,некоторые генераторы поддерживают различные варанты в виде наборов инструментов(ключ -T) и платформ (ключ -A). Для совместимости
с предыдущими версиями инструмента cmake возможно указание платформы в названии генератора.Например:
cmake -G "visual studio 11 2012" -A ARM ..\project_src
cmake -G "visual studio 11 2012 ARM" ..\project_src
или
cmake -G "visual studio 11 2012" -A X64 ..\project_src
cmake -G "visual studio 11 2012 Win64" ..\project_src
	При отсутствии ключа -G к cli cmake выбирается некоторый генератор по умолчанию для данной платформы
	В именах генераторов для visual studio c++ можно опускать номер года.Например
cmake -G "visual studio 11 2012 Win64" ..\project_src
	Входные файлы
	Входными файлами на языке cmake являются файлы CMakeLists.txt, лежащие в корне каталога проекта(со всеми исходниками).Путь к катологу проекта передается
в cli в качестве последнего аргумента.Круаные проекты могут также содержать подкаталоги с проектаим нижнего уровня, каждый из которых будет иметь в корне свой
CMakeLists.txt файл.Каталоги с подпроектами подключаются из файла на языке cmake при попощи команды add_subdirectory().Для каждого обрабатываемого файла CMakeLists.txt
система cmake создает в выходном каталоге подкаталог, служащий по умолчанию каталогом для промежуточных и выходных файлов этого (под)проекта, генерируя в нем все
необходимые файлы для используемоый конечной системы построеня.
	Кроме файлов CMakeLists.txt также могут использоваться файлы с расширением .make.Эти файлы могут подключаться из программы на языке cmake при помощи директивы include(),
вызываться при исполнении команды find_package() или передаваться инструменту cmake для исполнения при помощи ключа командной строки -P.При исполнении этих файлов система cmake не создает
отдельных выходных каталогов и не генерирует файлов для построения.
	В процессе генерирования файлов описания проектов cmake определяет в них зависимости от входных файлов.Изменения в них приведут при запуске построения конечной системой к повторному
вызову инструмента cmake, который перегенерирует описания проектов.Таким образом, автоматически отслеживаются ситуации изменения входных файлов cmake.
	Пути
	Следует обратить внимание на то что система cmake использует абсолютные пути везде где это возможно.В генерируемых файлах проектов для конечных систем построения содержатся абсолютные пути
к исходным, промежуточным и конечным файлам.Определяемые пользователем пути поиска заголовочных файлов при генерировании преобразутся в абсолютные и тд.Специальные переменные, хранящие пути к файлам
и каталогам(такие как CMAKE_SOURCE_DIR), содержат абсолютные пути.На платформах, файловые системы которых нечувствительны к регистру имен файлов, символы путей преобразуются к тому регистру, в котором
они хранятся в системе.
	Такой подход ускоряет и упрощает процесс генерирования файлов для конечных систем построения.Например, для проверки того , указывают ли два пути на один и тот же файл или каталог, достаточно проверить
эти строки на равенство.Кроме этого, генерируемые файлы реализуют требуемые от них ф-ции построения более надежным образом.Например,в make-файле указываются абсолютные пути к вызываемым инструментам, что делает
процесс построения независимым от значения переменной окружения PATH и других общесистемных настроек.
	Однако исользование абсолютных путей также накладывает на разработчика определенные обязательства.Так , при перемещении каталога проекта или каталога построения в файловой системе приходится заново генерировать
файлы повтроным запуском cmake.Понимание принципа использования абсолютных путей позволяет избежать многих типичных ошибок при использовании cmake в качестве системы построения проекта.
	Синтаксис
	Команды
	Программа на cmake состоит из последовательности команд, исполняемых интерпритатором.Синтаксис команды:
	<имя команды>([<аргумент1>...<аргумент2>])
	Замечание:аргументы команд разделяются символами-разделителями, а не запятыми.
	В качестве символа-разделителя могут использоваться один или несколько пробелов, символ табуляции и перевода строки.Таким образом, в отличие от make, qmake и тд при записи длинной команды в несколько строк
не нужно завершать каждую из них символом \.
	Языком поддерживаются однострочные комменты, начинаюзиеся с символа #.Также, начиная с cmake 3.0, поддерживаются блочные комменты между символами #[[ и ]]
	Команды являются единственным средством в языке, при помощи них, например, записываются все управляющие конструкции

if(WIN32)
	message(STATUS "Building for windows")
endif()

Замечание:все инструкции, включая endif() в примере выше, являются командами, поэтому после них необходимо ставить скобки.
	Как правило,команды поддерживают переменное количество аргументов
	Строки
	Аргументами команд являются строки.Как и в языках make и тд строки-это последовательности символови escape-последовательностей.Чтобы включить в строку символ-разделитель, можно заключить ее в двойные кавычки.В этом случае
интерпритатор будет считать данне символы частью строки, а не разделителем аргументов.Строки в кавычках могут занимать несколько строк в тексте программы, при этом символ \ в конце строки текста приводит к тому что следующий за ним
символ перевода строки не будет считаться частью строки.
	Пример
message(
	"AB\nCD
	\tEF\
	GH \${DATA}\"\\#"
	)
выведет на консоль:
AB
CD
	EF GH ${DATA}"\#

-Команда выполняет первый перевод строки после символов AB, так как в строковой константе после них указан escape-символ \n
-следующий перевод строки после CD указан в строке явно
-следующая строка начинается с \t, символ перевода строки после EF подавляется символов \ в конце строки.Таким образом,после символа EF на печать выводится два пробела и смиволы GH
-за символами GH выводится пробел, так как он считается частью строки, ограниченной двумя кавычками.
-дальше выводится символы ${DATA}.Если бы в строковой константе перед $ не было бы escape-символа \, конструкция ${DATA} внутри строковой константы считалась бы ссылкой на переменную с именем DATA и была бы заменена ее значением.
	Хотя все данные в cmake имеют строковый тип, в некоторых слуаях строковые значения служат в качестве  данных другого типа.Так, строки используются для представляения чисел в десятичной записи-как целых, так и с плавающей точкой.
Формат записи аналогичен другим яп.
	При использовании управляющих конструкций необходим способ представления логических значений.Для этого могут быть использованы различные строковые значения

TRUE FALSE
YES NO
Y N
ON OFF
0 IGNORE NOTFOUND " "
	Запись всех именованных логических констант нечувствительна к регистру.Значения, заканчивающиеся на -NOTFOUND, можно использовать для проверки результатов успешност поиска файлов, библиотек и тд при помощи команд find_file(), find_library() и тд
которые записывают путь к найденному объекту в заданную переменную.Если поиск закончился неудачей, эти команды записывают в переменную ее имя, дополненное суффиксом -NOTFOUND.
	Другим типом данных, поддерживаемых языком cmake, является список.Списки представляются пр помощи обычных строк, внутри которых символы ; раделяют соседние элементы.Перебор элементов списка можно выполнять при помощи команд foreach() и endforeach().
При передаче списков в команды в качестве аргументов их элементы передаются внутрь команд несколькими аргументами вместо одного.Чтобы заставить команду воспринимать список как один аргумент, его можно поместить в двойные кавычки.
	пример
message(a;b;c;)
message("a;b;c")
	вывод
abc
a;b;c

	Здесь первая команда message() получит три аргумента a,b и c. Команда выводит свои аргументы друг за другом без пробелов.Вторая команда message() получит один аргумент строку a;b;c

	Переменные
	Так же как и в языке burn shell и тд в cmake есть поддержка переменных строкового типа.Значения переменных могут использоваться внутри аргументов команд при помощи конструкции ${VAR_NAME}

	пример

set(GREETING Hello)
message("${GREETING} world!")

	Здесь переменной GREETING присваивается значение Hello, после чего выводится сообщение Hello world!
	Кроме пользовательских переменных в cmake также существует множество встроенных, имеющих специальное назначение.
	Имена переменных чувствительны к регистру и могут состоять почти из любых символов.
Замечание:при обработке проектов система cmake создает переменные с именами вида <имя_проекта>_SOURCE_DIR.Более свободные по сравнению с другими яп правила именования переменных позволяют накладывать
ограничения на названия проектов.Например имя 01-hello_SOURCE_DIR является допустимым, хотя лексический анализиатор большенства яп мог бы воспринять его как арифметическое выражение
	Как и в других яп, переменные имеют облатсь действия.Области действия определяются следующими сущностями:
1.Ф-ция.Ф-ции cmake определяют пользовательские команды, которые могут использовать локальные перменные.Ф-ции определяются при помощи команд function() и endfunction()
2.Каталог (под)проекта.Каждый обрабатываемый каталог исходных файлов со своим описанием CMakeLists.txt задает собственную область действия переменных.Перед началом обработки подпроекта с собственным файлом
CMakeLists.txt система CMake копирует в новую область все переменные из продительской области.Сценарии, запучскаемые cmake -P ... также задают область действия.
3.Кэш.Некоторые переменные могут быть определены в программе как предназначенные для постоянного хранения в файле CMakeLists.txt, записываемом  в выходной каталог.Эти переменные будут сохранять свои значения
между повторными запусками cmake.Значения переменных можно редактировать,например, при помощи графической утилиты ccmake.Переменные кэша предназначены для хранения изменяемых настроек построения проекта.Первый запуск
cmake заполняет их некоторыми значениями по умолчанию, последующие запуски
Замечания:
-В отличие от подпроектов, подключаемых командой add_subdirectory(),модули cmake, которые подключаются командой include(), отдельной области действяи переменных не образуют
-Область действия также относится и к специальным переменным.То есть их значения и действие ограничиваются текущей областью.Таким образом, статус специальной переменной определяется ее именем.При этом в разных областях
действия могут существовать разные специальные переменные с одним и тем же именем.
-переменные которые создаются в командной строке при выхове инструмента cmake с помощью ключа -D попдают в кэш
	При исполнении команд каждая найденная ссылка на переменную ${VAR_NAME} заменяется ее значением.Поиск значения выполняется от вершины в глубину стека областей действия переменных, образуемого динамически вложенными вызовами ф-ций.
Последней просматривается область действия текущего интерпритируемого файла CMakeLists.txt(если переменная не была найдена ранее), а после нее область кэша.Если переменная нигде не найдена, ссыдка на нее заменяется пустой строкой.
	Для установки значения переменных в cmake используется ряд команд
	Специальная конструкция ENV{<имя переменной>} может быть использована для доступа к переменной окружения работающего процесса cmake.Она может использоваться везде, где можно применить обычные переменные(не кэша).Доступ к значению переменной
окружения осуществляется пр помощи $ENV{<имя переменной>}
	пример
set(ENV{PATH} "$ENV{PATH};${CMAKE_BINARY_DIR}")
	Здесь при помощи команды set() к переменной окружения PATH добавляется через точку с запятой путь к каталогу построения проекта верхнего уровня, который хранится в специальной переменной CMAKE_BINARY_DIR.Переменная окружения PATH в различных
системах содержит список каталогов, в которых осуществляется поиск, в частности, исполняемых файлов при указании их имени в командной строке
Замечания:
-В разных системах пути в переменной окружения PATH могут отделяться друг от друга разными символами.В POSIX совместимых системах для этого используется двоеточие
-Выполненное в примере выше изменение переменной окружения, унаследованной процессом cmake от родителя, будет действительно только для этого процесса на время его работы.Оно не повлияет на значение этой переменной для родительского процесса или процессов, которые
будут в дальнейшейм выполнять построение проекта.Чтобы установить значения переменных окружения для инструментов, которые запускаются во время исполнения правил, определяемых командами add_custom_target() и add_custom_command(),можно воспользоваться командой
cmake -E env...
-cmake выдвигает те же требования к именам переменных окружения, что и для своих переменных.В частности, в именах переменных недопустимы скобки.Это затрудняет использование переменной окуржения ProgramFiles(x86), определенной в 64-битной системе
	Свойства
Свойства аналогичны переменным, но относятся к различным объектам:
-каталогам проектов (как каталогам верхнего уровня, передаваемым cmake в качестве аргумента командной строки,так и подключаемым при помощи команды add_subdirectory().
-целям
-тестам
-исходным файлам
-переменным, хранящимся в кэше
-файлам для установки
	Также существуют глобальные свойства.Как и переменные, свойства могут быть стандартными(имеющими определенное назначение).Изменение таких свойств приводит к определенным изменениям в генерируемой системе построения.В дальнейшем стандартные свойства будут
рассматриваться по мере необходимости.Некоторые стандартные свойства доступны только для чтения.Таким образом, можно провести аналогию между свойствами cmake и свойствами классов в ооп
	Для считывания и установки значений свойств используеются коанды get_property() и set_property()
Замечание:в отличие от переменных, которые имеют области действия, свойства всегда связаны с объектами, для которых они определены.Например, глобальное свойство с заданным  именем всегда существует в единственном экземпляре, в то время как одновременно может существовать
сразу несколко переменных с одним именем а разных областях действия.
	Примеры построения простых проектов
	Прежде чем приступать к изучению основных команд cmake, рассмотрим несколько примеров его использования
Пример
Пусть требуется построить проект из одного файла, в результате чего должен быть создан исполняемый модуль.Рассмотрим возможную структуру каталогов проекта на рисунке catalog_topology.png.Здесь в некоторой рабочей папке находятся каталог исходников(test_cmake) и каталог построения (build_catalog_for_test)
В этом примере оба каталога расположены рядом друг с другом для упрощения команды вызова cmake
	Для решения задачи в каталоге проекта должен содержаться файл CMakeLists.txt с содержимым которое находится ниже в картинке catalog_topology.png
Первая строка в этом файле является комментарием.Дальше следует команда project(), задающая имя проекта. Это имя будет использовано при создании системы построения в качестве имени решения или основного проекта
	Последняя строка содержит команду add_executable(), которая определяет новую цель построения с именем test_cmake и исходным файлом main.cpp.По умолчанию построение цели должно привести к созданию исполняемого файла с тем же именем, что и имя цели (test_cmake) в выходном каталоге проекта.
	Если в далнейшем необходимо добавить в проект другие исходники, их имена можно добавить в список аргументов команды add_executable().
Для удобства можно создать файл сценария build.cmd/build.sh рядом с каталогом build_catalog_for_test, при помощи которого можно автоматизировать процесс построения вызовом инструмента cmake с нужными аргами.Содержимое этого файла является специфичным для компьютера, на котором выполняется построение.
Пример
Пусть необходимо построить проект содержащий две цели:статическую библиотеку и приложение которое использует эту библу.Файлы в каталоге проекта построены как в папке build2.
	Здесь исходные файлы библиотеки и приложения расположены в двух подкаталогах проектов нижнего уровня,каждый из которых имеет собственный файл описания CMakeLists.txt.Оба проекта объединяются третьим файлом CMakeLists.txt, расположенным на каталог выше, в корне составного проекта.Эти файлы могут иметь следующее содержание
	Файл CMakeLists.txt верхнего уровня:

cmake_minimum_required(VERSION 2.8)
project(lib)
add_subdirectory(sample_lib)
add_subdirectory(sample_prog)

	Файл CMakeLists.txt проекта библиотеки:

add_library(sample_lib sample_mod.cpp sample_mod.h)

	Файл CMakeLists.txt проекта исполняемого файла:

add_executable(sample_prog main.cpp)
include_directories(../sample_lib)
target_link_libraries(sample_prog sample_lib)

	Описание проекта верхнего уровня начинается с команды cmake_minimum_required(), устанавливающей наименьшую версию инструмента CMake, которым может быть обработан проект.
Далее устанавливается название проекта пр помощи команды project().Затем к проекту присоединяются два проекта нижнего уровня пр помощи команд add_subdirectory(), задающих пути к подкаталогам.
	Описание проекта библиотеки содержит единственную команду add_library(), в которой задаются имя цкли и список исходных файлов проекта.Сборка проекта должна привести к созданию статической библы
в выходном каталоге проекта sample_lib(подкаталога sample_lib выходного каталога проекта верзнего уровня).Имя файла библиотеки будет по умолчанию совпадать с именем цели sample_lib с префиксом и расширением,
зависящем от компилятора.Например для компилятора gcc имя библы будет libsample_lib.a.
	Описание проекта приложения отличается от предыдущего добавлением двух новых команд.Команда include_directories() определяет дополнительные пути поиска заголовочных файлов компилятором.В подкаталоге sample_lib
находится заголовок sample_mod.h с описаниями, необходимыми для использования библиотеки.Исполнение команды include_directories() приводит к тому, что в генерируемом проекте команда для компляции исходных файлов проекта
sample_prog будет содержать аргумент командной строки передающий компилятору путь к каталогу sample_lib.Например, для компилятора gcc это будет ключ -I с путем:
gcc ... -I<путь к sample_lib>...
	Таким образом, исходных файлах проекта приложения можно использовать следующую директиву:

#inlude "sample_mod.h"

вместо

#include "../sample_lib/sample_mod.h"

	Наконец, команда target_link_libraries() определяет зависимость цели sample_prog от sample_lib.Кроме того, команда устанавливает, что при построении цели sample_prog будет использоваться библиотека, создаваемая в результате
построения цели sample_lib.
	В заврешении осталось рассмотреть вопрос о том, каким образом можно указать системе cmake, что при построении цели sample_lib необходимо создать статическую библу, как требуется по условию.Дело в том, что по умолчанию команда add_library() может
приводить к генерированию правил для создания динамической библы.Сборка цели в виде статической библы можно добиться тремя способами:
1.Можно при вызове cmake в cli определить значение специальной переменной BUILD_SHARED_LIBS как FALSE:
cmake -G "..." -D BUILD_SHARED_LIBS = 0 ../lib
	Здесь в качестве значения по умолчанию можно указать любую строку, означающую ложь.Таким образом, тип библы можно определить в cli
2.Если необходимо построение стстик библы в люом случае, можно упростить команду вызова cmake, выполнив нужное присваивание прямо в тексте описания проекта:
set(BUILD_SHARED_LIBS FALSE)
	Эту команду можно вставить в файл CMakeLists.txt проекта верхнего уровня или проекта библы.Она повлияет на поведение всех команд add_library(), исполняемых после нее в текущей области действия переменной BUILD_SHARED_LIBS.
3.Наконец, тип библы можно указать приямо в команде add_library(), передав ей аргумент STATIC:

add_library(
sample_lib STATIC
sample_mod.cpp
sample_mod.h)

	Эта настройка будет влиять только на данную цель.

	Команды общего назначения

	cmake_minimum_required()
cmake_minimum_required(VERSION <версия> [FATAL_ERROR])
	Команда определяет минимальную версию инструмента cmake, при помощи которого можно обрабатывать текущий входной файл проекта.Аргумент <версия> может содержать до 4 чисел, разделенных точками.
	Если версия cmake окажется ниже заданной, обработка файла остановится с сообщением об ошибке.
-Необязательный аргумент FATAL_ERROR имеет значение для версии cmake 2.4 или ниже-с ним команда приведет к останову с ошибкой вместо обычного рпедупреждения
	Команда в соответствии с номером версии также устанавливает политику совместимости-набор аспектов поведения cmake, делающий его совместимым с рпедыдущей версией.Множество аспектов поведения cmake может
меняться от версии к версии.Явное указание политик совместимости желательно, поскольку обеспечивает корректную обработку описанний проектов при переходе на новую версию cmake.
	cmake_minimum_required() рекомендуется указывать самой первой в файле CMakeLists.txt верхнего уровня.Если команда еще не исполнялась и cmake требуется выполнить действие, зависящее от политики совместимости,
он выведет предупреждение.
	project()
	project(
		<имя проекта>
		[VERSION <версия>] [LANGUAGES <язык1>...<языкn>])
	Команда устанавливает имя для иерархии проектов.Например, для генераторов microsoft VS это имя определяет имя создаваемого решения
-После необязательного аргумента VERSION можно указать версию проекта-строку до 4 чисел, разделенных точками(по умолчанию ставится пустая строка).Установка версии проекта доступна начиная с cmake 3.0
-После необязательного аргумента LANGUAGES указываются яп, для которых обеспечивается поддержка в проекте.По умолчанию установлен c/с++.Если после арга LANGUAGES добавить NONE, поддержка всех языков будет отключена.
Если в project() не определена версия проекта, аргумент LANGUAGES можно пропустить.Передача арга LANGUAGES доступна в cmake 3.0+
	Команда устанавливает значения нескольким специальным переменным CMake
	Некоторые переменные, устанавливаемые командой project)(
	имя переменной 					значение
	PROJECT_NAME					имя проекта, определяемое командой
	PROJECT_SOURCE_DIR				полный путь к каталогу проекта верхнего уровня(каталог исходников)
	<имя проекта>_SOURCE_DIR		то же самое
	PROJECT_BINARY_DIR				полный путь к каталогу построения верхнего уровня(каталог выходных и промежуточных файлов)
	<имя проекта>_BINERY_DIR		то же самое
	PROJECT_VERSION					версия проекта, указанная после VERSION
	<имя проекта>_VERSION			то же самое
	Команду project() рекомендуется указывать в файле CMakeLists.txt верхнего уровня.Она должна быть указана в явном виде(не внутри модулей подключаемых include()).
Если ее там нет, система создает проект с некоторым именем по умолчанию.Внутри файлов CMakeLists.txt для подпроектов эту команду имеет смысл указывать, если эти проекты вместе с проектами, от которых для них установлены
зависимости, могут собираться отдельно от остального набора проектов.В этом случае для подпроектов будут сгенерированы отдельные решения, которые будут обрабатываться интегрированной средой гораздо быстрее полного набора(обычно при открытии решений
иде собирает инфу обо всех исходных файлах с целью построения информации для быстрого перехода и тд)
	include()
	include(
	<файл> | <модуль>
	[OPTIONAL] [RESULT_VARIBLE <имя переменной>])
	Загружает из внешнего файла и исполняет заданный модуль cmake.Модуль может задаваться при помощи пути к файлу(включая расширение .cmake, относительный путь определяет местонахождение относительно каталога проекта) либо только именем модуля(без пути и расширения).
В последнем случае файл с именем <модуль>.cmake ищется в каталогах, список которых задан в переменной CMAKE_MODULE_PATH(по умолчанию пустая), и затем в каталоге стандартных модулей, поставляемых с cmake.
-если указан необязательный арг OPTIONAL, исполнение команды include() не приведет к ошибке, если указанный модуль не будет найден.Это может быть полезным в тех случаях, когда какие-то необязательные для построения компоненты проекта не восстанавливаются из репозитория
исходных кодов и не собираются в целых экономии времени
-после RESULT_VARIBLE можно указать имя переменной, в которую будет записан полный путь к найденному модулю или значение NOTFOUND, если модуль не будет найден.Таким образом, можно программно проконтролировать успешность загрузки модуля
	message()
	message([<режим>] <строка1>...<строка2>)
<режим>::= STATUS|WARNING|AUTHOR_WARNING|SEND_ERROR|FATAL_ERROR|DEPRICATION
	Команда предназначена для вывода сообщения различными утилитами cmake, интерпритирующими входной файл.Консольная программа cmake выводти сообщение в стандартный поток вывода при использовании режима STATUS и в стандартный поток ошибок а остальных случаях.Другие утилиты
выводят сообщения в окно журнала, в виде диалоговых окон и тд.
	Выводимое сообщение получается в резульатате конкатенации строк, передаваемых команде
-При помощи первого арга можно указать режим, который влияет на способ отображения сообщения, способ его форматирования, а также дальнейшее поведение cmake.Он может продолжить или прервать обработку входного файла, а также выполнить или пропустить генерацию файлов для конечной системы построения
	режимы выполнения команды message()
режим 				описание 							обработка	генерация
не указан			важная инфа							+			+
STATUS 				обычная инфа						+			+
WARNING 			предупреждение						+			+
AUTHOR_WARNING 		предупреждение для разраба			+			+
SEND_ERROR			локальная ошибка					+			-
FATAL_ERROR			серьезная ошибка					-			-
DEPRICATION			использование устарешвей фишки		зависит от настроек
	При исполнении команды message(DEPRICATION...) поведение cmake зависит от значений специальных переменных CMAKE_ERROR_DEPRECATED И CMAKE_WARN_DEPRECATED.Если первая из них содержит значение истина, поведение аналогично режиму FATAL_ERROR, иначе, если  вторая содержит значений истина-режим WARNING.
Иначе обработка файла и генерация продложаются, и сообщение не выводится.По умолчанию обе переменные содержат значение FALSE
	Команды описания целей
	add_executable()
	add_executable(
	<логическое имя цели>
	[WIN32][MACOSX_BUILD][EXCLUDE_FROM_ALL]
	<исходный модуль1>...<исходный модульn>)
	Команда добавляет к проекту цель с заданным логическим именем, построение которой из уникальных исходных модулей должно привести к созданию исполняемого файла
	Имя исполняемого файла формируется из имени цели и расширения.Изменить имя можно также при помощи установки свойства OUTPUT_NAME цели
	По умолчанию файл должен в подкаталоге построения, соответствующем текущему обрабатываемому подкаталогу проекта.Изменить этот каталог можно при помощи установки соответствующего свойства цели, которое изначально инициализируется значением специальной переменной CMAKE_RUNTIME_OUTPUT_DIRECTORY.Конечные
системы построения, которые поддерживают множественные конфигурации,могут добавлять к этому пути еще один вложенный каталог, соответствующий имени используемой конфигурации
-передача команде необязательного аргумента WIN32 приводит к точу, что при построении для windows приложение не будет иметь создаваемой по умолчанию консоли, даже если главной ф-цией программы является ф-ция main(), а не Winmain().Это достигается передачей компоновщику аргумента cli, зависящего от компилятора.
Например, для системы gcc-MinGW компоновщику передается ключ -Wl, --subsystem, windows.Это бывает удобно, в чатсности для разработки с использованием QT.
	При использовании арга WIN32 можно обойтись без ф-ции Winmain(), таким образом, упростить переносимость кода.Для остальных платформ этот арг игнорируется.
-передача MACOSX_BUILD сообщит системе cmake, что создваемый исполняемый файл должен быть пакетом приложения системы OSX
-передача EXCLUDE_FROM_ALL приводит к тому что генерируемая цель будет исключена из цели all.Таким образом, например, при работе с системой make команда make или make all приведет к построению данной цели, только если от нее зависимы другие цели, включенные в all
Замечание: при использовании компилятора visual c++ передачи аргумента WIN32 команде add_executable() недостаточно, если требуется использовать ф-цию main() в качестве точки входа.В этом случае также требуется передача компоновщику ключа
/ENTRY:mainCRTSartup
	add_library()
1.	add_library(
	<логическое имя цели>
	[STATIC|SHARED|MODULE]
	[EXCLUDE_FROM_ALL]
	<исходный модуль1>...<исходный модульn>)

2.	add_library(
	<логическое имя цели>
	<тип библы>
	IMPORTED)
	<тип библы>::=SHARED|STATIC|MODULE|UNKNOWN

	Первая форма команды add_executable(), но создает цель для построения библы
	Имя библы будет сформировано из базового имени(по умолчанию соответствующего имени цели):например <имя>.lib для visual c++, lib<имя>.a для gcc и тд
	По умолчанию библа будет создана в подкаталоге построения, соответствующем текущему обрабатываемому подкаталогу проекта.Изменить расположение библы можно при помощи установки свойств цели, которые инициализируется значениями специальных переменных.
Как и в случае с командой add_executable(), конечные системы построения могут добавлять к этим поутям каталог с именем используемой конфигурации
	специальные переменные, определяющие выходные каталоги для библа
переменная 								виды библ
CMAKE_ARCHIVE_OUTPUT_DIRECTORY			статик(+импорта)
CMAKE_RUNTIME_OUTPUT_DIRECTORY			DLL
CMAKE_LIBRARY_OUTPUT_DIRECTORY			модули, разделяемые
-типа библ можно задачать пр помощи необязательного арга:
	1.STATIC:статическая
	2.SHARED:динамическая
	3.MODULE: разделяемая, предназначенная исключительно для загрузки при помощи ф-ций api(pisix dlopen() и тд).Такой тип библ испольуется для реализации загружаемых модулей
	По умолчанию создаются правила для построения разделяемой библы,если переменная BUILD_SHARED_LIBS содержит истинное значение,  и статик, если иначе
	Таблица выше нуждается в пояснении.При построении все статические библы помещаются в каталог, определяемый переменной CMAKE_ARCHIVE_OUTPUT_DIRECTORY.Аналогично, все загружаемые модули попадают в каталог, путь к которому задается переменной CMAKE_LIBRARY_OUTPUT_DIRECTORY.
Сложнее с разделяемыми библиотеками.Дело в том что posix-совместимых системах разделяемые библы принято помещать в специальные каталоги-туде же, где находятся и статические библы.При создании
процесса динамический загрузчик исполняемого файла будет искать все требуемые для него библы в этих каталогах.Некоторые из этих путей могут быть заданы системной переменной (переменной окружения LD_LIBRARY_PATH).Другие из этих путей могут храниться в относительном виде в самом
исполняемом файле.Если библы будут расположены в другом месте, загрузчик не сможет их найти.Как правило, исполняемые файлы помещаются в каталог с именем bin, а разделяемые библы -в каталог рядом lib.Таким образом, разделяемые библы помещаются при построении в каталог, путь к которому
задается переменной CMAKE_LIBRARY_OUTPUT_DIRECTORY.
	В системах совместимых с windows динамические библы ищутся загрузчиком прежде всего в тех же каталогах что и исполняемые файлы.Например, динамическая библа может находиться в том же каталоге что и использующая ее программа.По этой причине динамические библы создаются при построении
проекта в таких системах в том же каталоге что и исполняемые модули то есть путь которому находтися в переменной CMAKE_RUNTIME_OUTPUT_DIRECTORY.При этом для облегчения процесса подключения дин библы к использующему ее приложению при ее построении также создается небольшая статическая библа,
содержащая инфу об экспортируемых символах динамической.Как и другие статические библы, библа импорта помещается в каталог путь к которой определяется переменной CMAKE_ARCHIVE_OUTPUT_DIRECTORY.
	Пример в build3
Пусть проект включает исполняемый файл и две библы, соторые он использует.Пусть структура проекта соответствует картинке build3.png
	В этом случае для формирования при построении системы выходных файлов каталогов, совместимой с рекомендациями GNU, можно использовать описание которое дано в описани проекта в каталоге верхнего уровня
	Здесь специальная переменная CMAKE_BINARY_DIR хранит полный путь к каталогу построения проекта верхнего уровня.Вместо нее в этом примере можно использовать переменную CMAKE_CURRENT_BINARY_DIR, в котрой хранится путь к каталогу построения текущего (под)проекта
	В результате обработки этого примера cmake и сборки проекта в windows каталог построения будет иметь структуру как на картинке buil3win.png, а в posix-совместимых системах как на картинке build3pos.png.Как можно видеть,в системе windows все выходные файлы будут помещены в один каталог, так что
при отладке приложения загрузчки сможет найти все требуемые ему библы.То же самое будет справедливо и для posix-систем.
	Вторая форма команды add_library() предназначена для добавления к проекту внешней заранее собранной библы (как правило стронней).Как и для предыдущей формы команды, создается цель с заданным логическим именем, которая по умолчанию имеет область видимости текущего каталога построения и ниже и которую
можно использовать как и остальные цели библиотек, для связывания с другими целями проекта при помощи команды target_link_libraries().Однако в этом случае не создается никаких правил построения библы.Чтобы указать меcтоположение файла библы для создаваемой цели, необходимо записать его в свойство цели IMPORTED_LOCATION,
а также в свойства IMPORTED_LOCATION_DEBUG и тд для каждой используемой конфигурации при помощи set_property().Для получения пути к исполняемому файлу библы можно использовать команду find_library().
	Вообще говоря, использовать дополнительную команду add_library(... IMPORTED) для того, чтобы подключить внешнюю библу, необяхательно, так как команда target_link_libraries() может получить на вход непосредственно пути к файлам библиотек вместо логических имен их целей.Однако команда позволяет существенно упростить повторное
использование библиотеки, поскольку для определяемой ею цели можно настроить свойства, используемые при построении зависимых целей(например, каталоги поиска заголовочных файлов).Таким образом, эти свойства не нужно устанавливать заново для каждой цели, к котрой подключается библа.К сожалению, цель библиотеки, которая определяется
это командой, нельзя передавать первым параметром командам target_link_libraries() и тд.Однако можно устанавливать соответствующие свойства цели командой set_property(), что менее удобно, но все равно не влияет на удобство описания зависимых целей.
	add_subdirectory()
	add_subdirectory(
	<подкаталог проекта>[<подкаталог построения>]
	[EXCLUDE_FROM_ALL])
	Команда добавляет к построению подпроект, расположенный в заданном подкаталоге.В нем должен находиться файл CMakeLists.txt с описанием подпроекта.Имеет смысл указывать относительный путь к каталогу, он будет определен относительно текущего каталога исходных файлов проекта
-При помощи необязательного аргумента <подкаталог ппостроения> можно указать подкаталог для выходных и промежуточных файлов подпроекта.Так же как и подкаталог проекта, он определяется относительно каталога построения текущего проекта.Если этот аргумент пропущен, в качестве него выбирается такой же относительный путь, что и <подкаталог проекта>
-При помощи передачи команде необязательного аргумента EXCLUDE_FROM_ALL можно исключить подпроект вместе со всеми зависимыми проектами из общего построения.При использовании системы make цель будет исключена из цели all.Таким образом, команда make или make all будет выполнять построение этого подпроекта только в том случае, если от него зависят
другие цели, строящиеся вместе с целью all.То же самое относится и к интегрированным средам в случае их использования:подпроект будет включен в общее решение, только если от него зависят другие проекты этого решения.В противном случае имеет смысл использовать команду project() в файле CMakeLists.txt подпроекта.Тогда система cmake создаст отдельное решение для
этого подпроекта и зависимых от него проектов.Обычно таким образом организуется подпроект, не обязательно для общего построения.
	Команды настройки целей
	include_directories()
	include_directories(
	[AFTER|BEFORE][SYSTEM]
	<каталог1>...<каталогn>)
	Команда include_directories() добавляет указанные каталоги к списку каталогов, в которых компилятор должен искать заголовочные файлы, подключаемые директивами #include.Эти каталоги добавляются к соответствующему свойству всех целей, определенных в текущем файле CMakeLists.txt.Относительные пути интерпритируются по отношению к текущему каталогу исходных файлов проекта.
При построении целей эти пути передаются компилятору при помощи аргументов cli, зависящих от конкретного компилятора.Например для gcc каждый путь передается при помощи ключа -I.
	При построении вне каталога проекта бывает необходимо добавить текущие каталоги исходных и выходных файлов к списку каталогов для поиска подключаемых файлов(значения, содержащиеся в переменных CMAKE_CURRENT_SOURCE_DIR и CMAKE_CURRENT_BINARY_DIR).Это бывает необходимо, если в выходном каталоге генерируются промежуточные подключаемые файлы.Добавить эти каталоги можно, установив
значени специальной переменной CMAKE_INCLUDE_CURRENT_DIR в истину
	set(CMAKE_INCLUDE_CURRENT_DIR ON)
-При помощи необязательного аргумента BEFOR, AFTER можно сообщить команде,что заданные в ней каталоги должны добавляться соответственно в начало ил конец списка каталогов для поиска.Если аргумент не указан, каталоги добавляются в начало, если специальная переменная CMAKE_INCLUDE_DIRECTORIES_BEFORE установлена в значение истина.
-При помощи необязательного аргумента SYSTEM можно сообщить, что указанные каталоги являются системными(относящимися к компилятору).Некоторые компиляторы в таком случае обрабатывают такие каталоги с некоторыми отличиями(не генерируют предупреждений, не создают инфу о зависимостях для находящихся в них файлов итд)
	target_link_directories()
	target_link_directories(
	<имя цели>
	[SYSTEM][BEFORE]
	INTERFACE|PUBLIC|PRIVATE
	[<каталог1>...<каталог1,m>]
	[
		INTERFACE|PUBLIC|PRIVATE
		[<каталог2,1>...<каталог2,n>]
	...
	])
	Команда target_link_directories() появлилась в cmake 2.8.11.Результат ее исполнения аналогичен вызову команды include_directories(), основные же отличия состоят в следующем:
-в аргументе команды указывается имя цели, к кторой она относится.Команда влияет на соответствующие свойства этой цели, в то время как команда include_directories() влияет на свойства каталога проекта
-есть возможность указать, будут ли использованы указанные а аргументах команды каталога для компиляции самой цели или зависимых от нее целей
	Перед путями к каталогам указывается один из следующих аргументов:
	PRIVATE:каталоги будут использованы для поиска заголовочных файлов при компиляции файлов текущей цели(аналогично include_directories())
	INTERFACE:каталоги будуи использованы при компиляции файлов зависимых целей от текущей
	PUBLIC:каталоги будут использованы при компиляции файлов как текущей цели, так и зависимых от нее целей(как будто использованы PRIVATE и INTERFACE)

	Таким образом, команда позволяет упростить подключение библиотек к исполняемым файлам
	Пример
Рассмотрим проект, состоящий из библиотеки и использующего ее приложения, аналогичный приведенному в примере на картинке interface.png
	С использованием команды target_include_directories() можно реализовать файлы описания проектов следующих образом:

	cmake_minimum_required(VERSION 2.8.11)

	project(interface)

	add_subdirectory(mylib)

	add_subdirectory(myprog)

	Здесь при помощи первой команды устанавливается минимальная версия cmake, поскольку команда terget_include_directories() появилась там

	Файл проекта библиотеки:

add_library(mylib_ l.cpp l.h)
target_link_libraries(myprog_ mylib_)

	Описание этого проекта упрощается по сравнению с предыдущими похожими примерами, так как в нем больше не нужно использовать команду include_directories().Достаточно лишь установить
зависимости между проектами при помощи команды target_link_libraries()
Замечание:для удобства в cmake есть специальная переменная CMAKE_INCLUDE_CURRENT_DIR_IN_INTERFACE, установка которой в истинное значение приводит к автоматическому добавлению каталога подпроекта
и каталога его построения в список подключаемых путей для зависимых целей.То есть эта переменная аналогична переменной CMAKE_INCLUDE_CURRENT_DIR, которая влияет на построение текущей цели.Таким образом
вызов команды target_include_directories() в примере выше можно заменить на команду:
set(CMAKE_INCLUDE_CURRENT_DIR_IN_INTERFACE ON)
	add_definitions(),add_compile_options()

	add_definitions(
	<определение1>...<определениеn>)

	add_compile_options(
	<аргумент1>...<аргументn>)
	Команда add_definitions() добавляет заданные определения символов препроцессора к свойствам текущего каталога и подчиненных(подключаемых при помощи команды add_subdirectory()).Определения символов должны быть
в формате -D<имя символа> или /D<имя символа>.Система cmake автоматически преобразует такие определения к аргументам командной строки , поддерживаемым используемым компилятором
пример
add_definitions(-DDEBUG -DEXTRA_TESTS)
	При использовании в построении компилятора gcc ему будут переданы аргументы -DDEBUG -DEXTRA_TESTS, а при использовании MVC++ /DDEBUG /DEXTRA_TESTS.После этого в компилируемых файлах препроцессором будут положительно обрабатываться
директивы вида:
#ifdef EXTRA_TESTS
	do_extra_tests();
#endif
	Определения в любом другом формате будут переданы без изменения компилятору в качестве аргументов командной строки.Однако в этом случае предпочтительнее ипользовать команду add_compile_options()(появилась в cmake 2.8.12),которая всегда приводит к
передаче компилятору заданных аргументов в неизменном виде.Так как доступные аргументы cli зависят от используемого компилятора, при их передаче необходимо использовать проверки на тип компилятора при помощи команды if() и специальных переменных, описывающих систему.
Пример
if(MSVC AND MSVC_VERSION GREATER 1400)
	add_compile_options(/MP)
endif()
	Здесь в случае использования компилятора MVC++ версии 2008 или выше ему при компиляции исходных файлов передается аргумент /MP, который приводит к распараллеливанию компиляции на доступное системе число процессорных ядер
Замечание:при использовании инструмента make добиться параллельного выполнения нескольких целей можно при помощи аргумента cli -j<количество процессов>
пример
make -j 8
Замечание:при передаче компилятору аргументов cli, отвечающих за некоторые часто используемые ф-ции, вместо add_compile_options() предпочтительнее использовать другие команды, которые способны передавать компилятору аргументы в поддерживаемом формате:
-для определения символов препроцессора с путсыми значениями предназначена команда add_definitions()
-для передачи компилятору дополнительных путей поиска заголовков предназначена команда include_directories(), которая оказывает влияение на свойства текущего каталога построения, а также команда target_include_directories(), которая определяет свойства определенной цели
-для передачи компоновщику дополнительных библиотек используется команда target_link_libraries().При помощи этой же команды можно передать компоновщику любые аргументы
-для передачи копилятору аргументов, делающих доступными возможности новых стандартов с/с++, используется команда target_compile_features()
-для передачи компоновщику дополнительных путей поиска библиотек используетя команда link_directories().Впрочем в реальных ситуациях эта команда почти никогда не нужна, так как при добавлении библиотек от других целей или найденных при помощи команд find_library() и тд компоновщику будет
передан полный путь к библе.
	target_compile_definitions()
	target_compile_definitions(
	<имя цели>
	INTERFACE|PUBLIC|PRIVATE
		[<определение1,1>...<определение1,m>]
	[
		INTERFACE|PUBLIC|PRIVATE
		[<определение2,1>...<орпеделение2,n>]
		...
	])
	Команда target_compile_definitions() доступна в системе cmake начиная с версии 2.8.11.Эта команда аналогична команде add_definitions(), однако позволяет добавлять определеня символов препроцессора через командную строку вызовов компилятора не только для указанной цели, но и автоматически для всех целей, зависимых от данной,
аналогично команде target_include_directories()
	target_compile_options()
	target_compile_options(
	<имя цели> [BEFORE]
	INTERFACE|PUBLIC|PRIVATE
		[<аргумент1,1>...<аргумент1,m>]
	[
		INTERFACE|PUBLIC|PRIVATE
			[<аргумент2,1>...<аргумент2,n>]
		...
	])
	Команда target_compile_options() доступна cmake начиная с 2.8.12.Эта команда аналогична команде add_compile_options(),однако позволяет передавать аргументы компилятору не только для указанной цели,но и автоматически для всех целей, зависимых от данной, аналогично команде target_compile_definitions()
-при помощи необязательного аргумента BEFORE можно добавлять аргументы компилятора в начало их списка вместо конца(по умолчанию)
	target_compile_features()
	target_compile_features(
	<имя цели>
	INTERFACE|PUBLIC|PRIVATE
		<возможность1>...<возможностьn>)
	Команда target_compile_features() доступна в cmake 3.1.0.Эта команда предназначена для передачи специфических для используемого компилятора аргументов, включающих заданные возможности новых стандартов с и с++.Передаваемые команде возможности должны быть перечислены в специальных переменных CMAKE_C_COMPILE_FEATURES и
CMAKE_CXX_COMPILE_FEATURES.Эти переменные содержат список возможностей, поддерживаемых выбранным компилятором, и являются подмножествами глобальных свойств CMAKE_C_KNOWN_FEATURES И CMAKE_CXX_KNOWN_FEATURES.
-Аргументы INTERFACE, PUBLIC и PRIVATE позволяют передавать ключи компилятора не только для указнной цели, но и автоматически для всех целей, зависимых от данной.Их смысл аналогичен таким же аргументам для команды target_include_directories().
	Если выбранный для построения компилятор не поддерживает указанную возможность, обрабботка описания проекта системой cmake прерывается и генерация файлов для конечной системы построения не вполняется(аналогично команде message(FATAL_ERROR ...)
	Замечание:хотя эта команда появилась в cmake 3.1.0, имеет смысл использовать ее как минимум с cmake 3.3.0, так как в ней стала доступной инфа о возможностях компиляторов gcc, mvc++ и тд.Для более новых компиляторов необходимо использовать более позднюю версию cmake.
	target_link_libraries()
	target_link_libraries(
	<имя цели>[<строка1>...<строкаn>]
	[
		[debug|optimized|general]<строка>
		...
	])
	target_link_libraries(
	<имя цели>
	INTERFACE|PUBLIC|PRIVATE <СТРОКА1>...<строкаm>
	[
		INTERFACE|PUBLIC|PRIVATE <строка1>...<строкаn>
	])
	Команда предназначена для определения подключаемых библиотек к заданной цели или произвольных аргументов командной строки, передаваемых компоновщику
Замечание:имя цели должно быть орпеделено в том же самом каталоге, внутри описания которого вызывается эта команда
	Команда определяет тип аргументов, начиная со второго, по следующим правилам:
1.Если передаваемая строка начинается с символов -l или -framework, то оставшаяся часть строки интерпритируется как имя библы(без префикса lib и расширения)
2.иначе, если передаваемая строка начинается с символа -, она нтерпритируется как аргумент командной строки для компоновщика и во время построения передается ему без изменений
3.Иначе, если строка совпадает с именем другой цели, ранее определенной при помощи команды add_library(), текущая цель будет строиться с испольщованием библы, которая ялвятеся
результатом построения указанной цели.Кроме этого, устанавливается зависимость при построении текущей цели от указанной, аналогично команде add-dependecies()
4.иначе строка должна представлять путь к файлу библы, которая будет использована при построении цели
	Несколько команд target_link_libraries(), последовательно исполняемых для одной и той же цели, добавляют новые настройки к процессу ее компоновки.
	Использование команды также транзитивно переносит на зависимую цель треббоания, определенные для целей связываемых библиотек при помощи интерфейсных аргументов команд target_link_directories() и других, имеющих префикс target_
	Замечание:по умолчанию устанавливаемые отношения зависимости между целями при помощи команды target_link_libraries() ялвяются транзитивными то есть распространяются на зависимые цели.Это может оказаться
нужным при построении приложения, используеющего ф-ции из билы, которая сама использует библы.Даже если библы являются статическими , следовательно, одни библы физически никак не учавствуют в компоновке других библ, они все вместе будут использоваться при
компоновке приложения.
	пример
	в папке build4
-При помощи необязательных аргументов debug, optimized|, general можно ограничить действие следующего аргумента на различных конфигурациях:
debug:следующий аргумент буедет применяться в конфигурации debug и во всех конфигах, перечисленных в глобальном св-ве DEBUG_CONFIGURATIONS
optimized:следующий аргумент будет применяться во всех остальных конфигах
general:следующий аргумент будет применяться во всех конфигах как и в случае когда перед настройкой не указан никакой из этих трех аргов
-Во второй форме команды, появившейся в cmake версии 2.8.12, перед аргами, определяющими подклчаемые библы, можно указать аргументы INTERFACE, PUBLIC, PRIVATE.Они позволяют переопределять стандартное поведение, когда настройки компоновщика транзитивно передаются
зависимым целям.Их смысл аналогичен таким же аргам для команды target_include_directories()
	add_dependencies()
	add_dependencies(
	<имя цели>[<имя цели1>...<имя целиn>])
	Команда устанавливает отношение зависимости при построении заданной цели от других.Команда аналогична команде target_link_libraries() за исключением того, что ее аргументы могут быть только именами целей и что она не устанавливает зависимостей по подключению библиотек в время
компоновки.По сравнению с ней эта команда применяется не так часто.Как правило, она используется при установлении зависимостей для целей, созданных командой add_custom_target()
	Команды обработки данных
	set(),unset(),option()
	set(<имя переменной> [<значение1>...<значениеn>])
	set(<имя переменной><значение>[CACHE<тип><строка описания>[FORCE]]|
	PARENT_SCOPE])
	<тип>::FILEPATH|PATH|STRING|BOOL|INTERNAL
	unset(<имя переменной> [CACHE|PARENT_SCOPE])
	option(<имя переменной><строка описания>[<значение>])
	Первый вариант команды set() предназначен для присваивания заданной переменной списка из заданных значений.Таким образом, переменной будет присвоено значение <значение1>...<значениеn>
	Второй вариант команды set()при указании аргумента CACHE или PARENT_SCOPE предназначен для установки значения переменной в друго области действия.В этом случае переменная не может быть переменной окружения
-При помощи необязательного аргумента CACHE указывается , что команде следует осуществлять присваивание переменной кэша.После этого аргумента указывается тип переменной и строка описания, которая будет использована в качестве информации о переменной в утилите cmake с гуи.Тип переменной
используется исключительно для удобства и влиет на способ редактирования значения переменной, предоставляемой гуи cmake.Возможны следующие значения типов:
	FILEPATH:в переменной хранится путь к файлу.Для редактирования возможно использовать диалоговое окно выбора файлам
	PATH:в переменной хранится путь к каталогу.Для редактирования возможно использовать диалоговое окно выбора каталогам
	STRING:в переменной хранится строка общего назначения.При редактировании используется обычное поле ввода строки
	BOOL:в переменной хранится логическое значение.Для редактирования будет использовано поле выключателя
	INTERNAL:утилита cmake не будет отображать инфу об этой переменной.Предполагается, что переменная используется для внутренних целей и должна храниться в кэше
После строки описания может быть указан необязательный аргумент FORCE.Его использование приводит к тому,что переменной будет присвоено значение в люом лучае, даже если она уже находтися в кэше.По умолчанию, если переменная уже там есть, присваивания не происходит.Такое поведение команды set()
подходит в большенстве случаев,так как позволяет сохранять ранее отредактированные значения кэша.Также при присваивании будет удалена из текущей области действия переменная с тем же именем.
-при помощи необязательного аргумента PARENT_SCOPE указывается, что следует осуществляеть присваивание переменной родительской области действия
	Команда unset позволяет удалить информацию о заданной переменной(cmake или окружения) то есть вернуться к состоянию до первого ее присваивания.Как и для предыдущей команды, необязательные аргументы CACHE и PARENT_SCOPE позволяют указать, к какой области действия следует применить команду.
	Команда option() аналогична команде set() с аргументами CACHE BOOL.По умолчанию переменной устанавливается значение OFF.
	Замечание:так как кэщ представляет собой отдельную область действия переменных, в нем могут храниться переменные с теми же именам, что и у переменных других областей.При этом такие переменные с одним именем будут разными
	Пример в каталоге build5/example1/
	При исполнении фрагмента кода в CMakeLists.txt выведутся следующие строки:
value 2
value 1
	Этот вывод демонстрирует принцип поиска переменных в различных областях действия.Превая команда message() обращается к переменной в текущей области действия.После удаления этой переменной вторая команда message() уже обращается к переменной кэша.
	Однако если в этот фрагмент внести небольшое изменение, входной файл с изменением находится в build5/example2
то в этом выводе cmake будет таким:
value 2
value 2
	Такой вывод происходит потому, что как было отмечано выше, вторая команда set() удаляет из текущей области переменную с тем же именем.При этом unset() попытается удалить инфу об уже не существующей переменной текущей области.
	math()
	math(EXPR <имя переменной> <выражение>)
	<выражение>:=<целочисленный_литерал>|
	(<выражение>)|
	<выражение> <операция> <выражение>

	<целочисленный литерал>:=
	<цифра>...<цифра>

	<операция>:=
	+,-,*,/,%,|,&,^,~,<<,>>

	Эта команда позволяет вычислить фрифметическое выражение и присвоить строковое представление его результата заданной переменной.Поддерживаются целочисленные операнды и бинарные операции, аналогичные языку С.
	Замечания:
-так как унарные операции командой не поддерживаются, выражения вида -4+1 являются неправильными с ее точки зрения.Для представления отрицательных чисел следует вычитать положительные литералы из нуля.
-при использовании пробелов внутри выражения его необходимо заключить в кавычки.
	list()
	Команда list() реализует основные алгоритмы работы со списками.Команда введена для удобства:ее использование необязательно,все задачи, которые она выполняет, можно решить другими средствами.Однако для сокращения
исходного текста описания проектов и для придания ему большей ясности рекуомендуется использовать эту команду там, где это возможно.
	Также как и set(), list() может создавать новые переменные.Однако она создает их всегда в текущей области действия, в отличие от set(), для которой можно указать аргументы CACHE, PARENT_SCOPE.Таким образом, новый список
создается в текущей области действия, даже если исходный список находится в другой области.Чтобы скопировать полученное значение в исходную облатсь, можно использовать команду set()
	Пример в каталоге build6
	Фрагмент кода в CMakeLists.txt выведет на печать a;b;c;d;e;f.Сначала в нем определяется команда test() при помощи команд function()/endfunction().Далее коменда set() присваивает значение переменной TEST_LIST.После этого
исполняется команда test(), которая добавляет в конец списка три хначения.В результате создается переменная с тем же именем TEST_LIST, но уже в области действия ф-ции.Чтобы скопировать значение этой переменной в исходную область действия,
используется команда set() с аргументом PARENT_SCOPE.
	При обращении к элементам списков можно использовать неотрицательные индексы 0,1,2,... для обращения к первому, второму и тд элементу с начала или -1,-2,... для обращения к первому, второму и тд с конца.
Замечание:пр передаче командам значений индексов вне диапазона элементов списка выводится сообщение об ошибке.Выполнение команд продложается, но генерирование файлов конечной сисетемы построения не происходит(как при message(SEND_ERROR...))
list(LENGTH <имя списка> <имя переменной>)
	Эта форма команды записывает в переменную длину списка
list(GET <имя списка><индекс1>...<индексn><имя переменной>)
	Эта форма команды записывает в заданную переменную список из значений исходного списка с заданными индексами
list(APPEND <имя списка> [<значение1>...<значениеn>])
	Эта форма команды дописывает в конец заданного списка заданные значения.Команда равносильна:
set(<имя списка> ${имя_списка} [<значение1>...<значениеn>)

list(FIND<имя списка><значение><имя переменной>)
	Эта форма команды находит в списке заданное значение и возвращает индекс его певрого вхождения(-1 при отсутствии)
list(INSERT <имя списка><индекс>[<значение1>...<значениеn>)
	Эта форма команды вставляет в заданную позицию списка заданное значение
list(REMOVE_ITEM <имя списка> <значение1>...<значениеn>)
	Эта форма удаляет из списка все схождения заданных значений
list(RMOVE_AT <имя списка><индекс1>...<индексn>)
	Эта форма удаляет из списка все элементы с заданным индексом(в исходном списке)
list(REMOVE_DUPLICATES<имя списка>)
	эта форма удаляет из списка все одинаковые элементы кроме их первых вхождений
list(REVERSE <имя списка>)
	эта форма меняет в списке порядок его элементов не противоположный
list(SORT <имя списка>)
	эта команда сортирует элементы списка по возрастанию в лексикографическом порядке
	string()
	Команда string() реализует основные алгоритмы обработки строк:выделение подстроки, поиск, замену и тд.В отличие от других языков,
в cmake нет средства для индексации отдельных элементов строк как массивов, поэтому команда string() ялвяется единственным доступным способом
анализа и изменения их содержимого.
string(<унарная операция> <строка> <имя переменной>)
<унарная операция>::=
	LENGTH|TOLOWER|TOUPPER|STRIP
-команда вызыванная с LENGTH, записывает в заданную переменную длину заданной строки
-команда с TOLOWER/TOUPPER записывает в переменную заданную строку в нижнем/верхнем регистре
-команда с STRIP записывает в переменную подстроку исходной строки без ведущих и завершающих пробелов
string(CONCAT <имя переменной> [<строка1>...<строкаn>])
	Команда string(CONCAT...) выполняет конкатенацию нескольких строк, записывая результат в заданную переменную.Таким образом эта команда позволяет легко преобразовывать
список в строку без разделителей(<<;>>)
string(FIND <строка> <подстрока> <имя переменной> [REVERSE])
	Команда string(FIND...) выполняет поиск в строке первого(или последнего, если используется REVERSE) вхождения подстроки, записывая индекс ее начала в заданную переменную.Позиция
в строке нумеруется с 0, при отсутствии подстроки возвращается -1
string(SUBSTRING <строка> <начало><длина><имя переменной>)
	Команда string(SUBSTRING...) выделяет из строки подстроку, начинающуюся с заданной позиции , заданной длины (или до конца, если в качестве длины указано -1), записывает результат в заданную переменную
string([REGEX]REPLACE <выражение поиска> <выражение замены> <имя переменной><строка1>...<строкаn>)
	Команда string(REPLACE...) выполняет замену всех выхожденй заданной подстроки, которая передается ей чез аргумент <выражение поиска>, на строку, которая передается через аргумент <выражение замены>, в строке,
являющейся конкатинацией строк, которые передаеются команде через последние аргументы.Измененная строка записывается в заданную переменную.
	Команда string(REGEX REPLACE...) работает аналогично, однако рассматривает свой аргумент <выражение поиска> как регулярное выражение , в выражение <выражение замены>-как выражени езамены, в котором могут встречаться
ссылки на части найденных подстрок(<<\<номер>>)
	string(REGEX <операция> <выражение поиска> <имя переменной> <строка1>...<строкаnЮ)
	<операция>::=MATCH|MATCHALL
	Команда string(REGEX MATCH ...) выполняет поиск первого вхожденя подстроки, удовлетворяющей заданному регулярному выражению, в строке, являющейся конкатинацией заданных строк.Найденная подстрока записывается в переменную.
Как и в предыдущей форме команды, выполняется выделение наиболее длинной подстроки, насколько это возможно.Если подстрока не найдена, возвращается пустая строка
	Команда string(REGEX MATCHALL...) работает аналогичным образом, но находит все возможные подстроки, соответствующие регулярному выражению, и возвращает их в виде списка
	Команды управляющих конструкций
	if(),elseif(),else(),endif()
	if(<условие1>)
		<команды>
	[
		elseif(<условие2>)
			<команды>
		...
	]
	[
		else()
			<команды>
	]
	endif()

	<условие>::=
		(<условие>) |
		NOT <условие>|
		<условие> AND <условие>|
		<условие> OR <условие> |
		<логическая константа> |
		<имя переменной>	   |
		<операция><путь>	   |
		<путь> IS_NEWR_THAN <путь> |
		<значение><бинарная операция><значение> |
		<значение> MATCHES <регулярное выражение> |
		COMMAND <имя> |
		TARGET <имя>  |
		DEFINED <имя переменной>

		<значение>::=
			<имя переменной>|<строка>

		<операция>::=
			EXISTS | IS_DIRECTORY | IS_SYMLINK | IS_ABSOLUTE

		<бинарная операция>::=
			LESS | GREATER | EQUAL | STRLESS | STRGREATER | STREQUAL | VERSION_LESS |
			VERSION_GREATER | VERSION_EQUAL
-команда if() вычисляет логическое выражение, которое составляет ее аргументы.Если его значение истинно, исполняются команды от текущего if() до первой соответствующей ей else(), elseif() или endif()
-иначе следующая команда elseif() проверяет условие.Если оно истино , исполняются команды до следующей elseif() и тд
-если все условия в if() и elseif() оказываются ложными, исполняются команды между else() и endif()
-Наличие команд elseif() и else() необязательны.Одной команде if() может соответствовать несколько команд elseif()
	Вычисление выражений происходит следующим образом:
	-скобки и операции OR, AND NOT имеют ту же семантику, что и в других яп
	-строка, соответствующая одному из значений логических констнат таблицы на картинке 2.1.png, интерпритируется в соответствии с этой таблицей.Названия логических констант нечувствительны к регистру
	-иначе строка интерпритируется как имя переменной.Выражение считается истинным, если в этой переменой не содержится значение ложь в соответствии с картинкой 2.1.png
	-также выражением может состоять из нескольких значений со строковыми обозначениями операций.Имена переменных в выражениях (<имя переменной>) эквивалентны их подстановкам :${имя переменной}.Гарантируется, что операции с путями будут давать правильные 
	результаты для абсолютных путей.
	Операции в логических выражениях(таблица 2.6)
	операция 			значение
				унарные 
	EXISTS				проверка того, является ли указанная строка путем к существующему файлу или каталогу в файловой системе
	IS_DIRECTORY 		проверка того, является ли указанная стока путем к существующему каталогу в файловой системе
	IS_SYMLINK			проверка того, является ли указанная строка путем к существующей символической ссылке в файловой системе
	IS_ABSOLUTE			проверка того, является ли указанная строка полным путем в файловой системе
	COMMAND				проверка того, является ли указанная строка именем команды cmake, макроса или ф-ции(определенной при помощи команды function())
	TARGET 				проверка того, является ли указанная строка именем цели (определенной при помощи add_executable())
	DEFINED 			проверка того, является ли указанная строка именем переменной с ранее установленным значением
			бинарные
	LESS,EQUAL,GREATER  аргументы операций интегрируются как десятичная запись с плавающей точкой вещественных чисел.Выполняется проверка того, является ли первое число меньше, равным или больше второго
	STRLESS,STREQUAL,	
	STRGREATER 			проверка того, является ли первая строка лексиграфически меньше, равной или больше второй
	VERSION_LESS,
	VERSION_EQUAL,
	VERSION_GREATER		аргументы операций интерпритируются как номера версий, содержащие до трех точек.Выполняется проверка того, является ли первый номер меньше, больше или равен второму
	MATCHES				проверка того, соответствует ли строка заданному регулярному выражению
	IS_NEWER_THAN		проверка того, является ли время изменения первого файла или каталога больше или равным времени изменения второго.Выражение истинно также в том случае, когда какой-либо из двух файлов или каталогов
						не существует в файловой системе.Таким образом , эта операция подходит для проверки зависимости между файлами во время построения проекта 
	Для операций установлены следующие приоритеты в порядке убывания:
1)унарные; 2)бинарные; 3)NOT; 4)AND; 5)OR
	Чтобы избежать неоднозначности, строки в выражениях можно указывать в кавычках.В этом случае они не будут интерпритироваться как имена переменных или операций.
	Основной областью применения команды if() является организация передачи различных настроек компилятору, компноновщику и тд.В зависимости от целевой ос и компиля.Для этого существует ряд специальных переменных cmake,доступных 
только для чтения, значения которых зависят от используемой среды(картинки 2.7.png, 2.8.png и 2.9.png)
	
	Логические переменные для тестирования целевой ос:
	APPLE*	UNIX**	WIN32
	WINC	WINDOWS_PHONE	WINDOWS_STORE
	*OS X
	**Переменная содержит истину для всех UNIX-подобных систем, таких как системы, основанные на ядре linux,os x, windows с набором инструментов cygwin и тд
	
	Логические переменные для тестирования используемого компилятора и окружения
константа					значение 
BORLAND						любой компиль фирмы borland/embarcadero
CMAKE_CL_64					64-битный компиль microsoft
CMAKE_COMPILER_IS_GNUCC		любая реализация компилятора gcc c
CMAKE_COMPILER_IS_GNUCXX	любая реализация компилятора gcc c++
CYGWIN						реализация cmake для cygwin
MINGW						реализация компилятоора mingw для windows
MSVC						microsoft c++ любой версии 
MSVC_IDE					microsoft c++ ide с проектами для среды microsoft vs в отличие от использования компилятора из CLI
MSVC60						VS C++ 6.0
MSVC70 						VS C++.NET 2002
MSVC71						VS C++.NET 2003
MSVC80						VS C++ 2005
MSVC90						VS C++ 2008
MSVC10						VS C++ 2010
MSVC11						VS C++ 2012
MSVC12						VS C++ 2013
MSVC14						VS C++ 2015
MSYS						реализация компилятора mingw с make-файлами для оболочки MSYS
WATCOM						компилятор open watcom для windows
	
	Переменные, хранящие версии компилятора 
MSVC_VERSION			XCODE_VERSION
	
	Значения переменной MSVC_VERSION соответствует значениям макроса _MSC_VER компилятора vs c++.Эти значения соответствуют первым двум компонентам версии компилятора и не совпадают с номером версии VS (картинка 2.10.png)
	
	Значения переменной MSVC_VERSION
Константа 				значение 
1200					vs c++ 6.0
1300					vs c++.NET 2002
1310					vs c++.NET 2003
1400					vs c++ 2005
1500					vs c++ 2008
1600					vs c++ 2010
1700					vs c++ 2012
1800					vs c++ 2013
1900					vs c++ 2015
	
	Например, в vs 2015 версия компилятора имеет два старших компонента, равных 19.0
	Переменная XCODE_VERSION содержит номер версии среды xcode, например 3.1.2
Пример
Следующий код, будучи помещенным в файл CMakeLists.txt корневого проекта, выполняет аварийный останов cmake в случае, если пользователь пытается зупустить построение проекта в том же каталоге, где находятся его исхдники:

cmake_minimum_required(VERSION 3.10)
set(MY_STR1 "hello")
set(MY_STR2 "hello")
if(MY_STR1 STREQUAL MY_STR2)
        message("str1 equal str2")
else()  
        message("string is not equal")
endif() 

if(CMAKE_SOURCE_DIR STREQUAL CMAKE_BINARY_DIR)
        message(
                FATAL_ERROR
                "Use build directory different fromsource directory")
endif()
	
	Для определения путей к каталогам проекта и построения используется тот факт, что система cmake хранит все пути в абсолютном представлении.Команда message() с аргументом FATAL_ERROR выполняет 
прерывание обработки проекта.Замечание:продемонстрированная в примере проверка может быть особенно полезной, если в результате построения в выходном каталоге генерируются файлы с именами, совпадающими
с именами исходных файлов.
	while(),endwhile(),break(),continue()
	while(<условие>)
		<команды>
	endwhile()
	break()
	continue()
	Команда while() вычисляет условие по таким же правилам, что и if().Пока это условие истинно, выполняются до команды 
endwhile()
	Команда break() досрочно прерывает выполнение ближайшего цикла while() и foreach()
	Команда continue(), появилась в cmake 3.2, досрочно переходит к следующей итерации ближайшего цикла.
	foreach(), endforeach()
	
	foreach(<имя переменной> <значение1>...<значениеn>)
		<команды>
	endforeach()
	
	foreach(
		<имя переменной> IN
		[LISTS [<список1>...<списокn>]]
		[ITEMS [<значение1>...<значениеn>]])
	
	foreach(<имя переменной> RANGE <максимум>)
	
	foreach(<имя переменной> RANGE <старт> <стоп> [<шаг>])
	
	Первая форма команды foreach() выполняет все команды до команды endforeach() в количестве ращ, равном соличеству передаваемых ей значений.При этом на каждой итерации цикла переменная с заданным именем будет принимать значения со второго по последний аргумент команды foreach()
	Вторая форма команды foreach() аналогична первой, но удобнее нее в определенных случаях.В ней можно указывать имена переменных списков, значения которых будут обходиться в цикле(после необязательного аргумента LISTS), а также сами значения непосредственно(после необязательного аргумента ITEMS).
Пустые списки рассматриваются как списки без элементов
	Третья форма команды foreach() выполняет тело цикла с целочисленными значениями переменной от 0 до заданного максимума.Таким образом, тело цикла выполняется максимум+1 раз.
	Наконец последняя форма foreach() выполняет тело цикла с целочисленными значениями переменной в заданном отрезке с заднным шагом (1 по умолчанию).Тело цикла выполняется, пока значение переменной не превышает значения <стоп>.Таким образом, цело цикла будет выполнено всего (<стоп>-<старт>+1)/шаг раз
	
