	Основы языка cmake
	Основые концепции
	Генераторы
	Генераторами называются компоненты cmake, отвечающие за создание проектов для конечных систем построения.Для каждой поддерживаемой
системы (make, visual studio) существует свой генератор.Выбор конкретного генератора задается в cli cmake при помощи ключа -G, например:
cmake -G "Visual Studio 14 2015" ..\project_src
	Здесь последний аргумент ..\project_src указывает утилите cmake с интерфейсом cli путь к катологу проекта.Текущий каталог, откуда запускает
программа cmake, будет каталогом построеня, в котором будут сгенерированы файлы проектов.
	Реализация cmake для различных платформ могут поддерживтаь разные наборы генераторов для данной версии можно узнать при помощи команды:
cmake --help
	Кроме этого,некоторые генераторы поддерживают различные варанты в виде наборов инструментов(ключ -T) и платформ (ключ -A). Для совместимости
с предыдущими версиями инструмента cmake возможно указание платформы в названии генератора.Например:
cmake -G "visual studio 11 2012" -A ARM ..\project_src
cmake -G "visual studio 11 2012 ARM" ..\project_src
или
cmake -G "visual studio 11 2012" -A X64 ..\project_src
cmake -G "visual studio 11 2012 Win64" ..\project_src
	При отсутствии ключа -G к cli cmake выбирается некоторый генератор по умолчанию для данной платформы
	В именах генераторов для visual studio c++ можно опускать номер года.Например
cmake -G "visual studio 11 2012 Win64" ..\project_src
	Входные файлы
	Входными файлами на языке cmake являются файлы CMakeLists.txt, лежащие в корне каталога проекта(со всеми исходниками).Путь к катологу проекта передается
в cli в качестве последнего аргумента.Круаные проекты могут также содержать подкаталоги с проектаим нижнего уровня, каждый из которых будет иметь в корне свой
CMakeLists.txt файл.Каталоги с подпроектами подключаются из файла на языке cmake при попощи команды add_subdirectory().Для каждого обрабатываемого файла CMakeLists.txt
система cmake создает в выходном каталоге подкаталог, служащий по умолчанию каталогом для промежуточных и выходных файлов этого (под)проекта, генерируя в нем все
необходимые файлы для используемоый конечной системы построеня.
	Кроме файлов CMakeLists.txt также могут использоваться файлы с расширением .make.Эти файлы могут подключаться из программы на языке cmake при помощи директивы include(),
вызываться при исполнении команды find_package() или передаваться инструменту cmake для исполнения при помощи ключа командной строки -P.При исполнении этих файлов система cmake не создает
отдельных выходных каталогов и не генерирует файлов для построения.
	В процессе генерирования файлов описания проектов cmake определяет в них зависимости от входных файлов.Изменения в них приведут при запуске построения конечной системой к повторному
вызову инструмента cmake, который перегенерирует описания проектов.Таким образом, автоматически отслеживаются ситуации изменения входных файлов cmake.
	Пути
	Следует обратить внимание на то что система cmake использует абсолютные пути везде где это возможно.В генерируемых файлах проектов для конечных систем построения содержатся абсолютные пути
к исходным, промежуточным и конечным файлам.Определяемые пользователем пути поиска заголовочных файлов при генерировании преобразутся в абсолютные и тд.Специальные переменные, хранящие пути к файлам
и каталогам(такие как CMAKE_SOURCE_DIR), содержат абсолютные пути.На платформах, файловые системы которых нечувствительны к регистру имен файлов, символы путей преобразуются к тому регистру, в котором
они хранятся в системе.
	Такой подход ускоряет и упрощает процесс генерирования файлов для конечных систем построения.Например, для проверки того , указывают ли два пути на один и тот же файл или каталог, достаточно проверить
эти строки на равенство.Кроме этого, генерируемые файлы реализуют требуемые от них ф-ции построения более надежным образом.Например,в make-файле указываются абсолютные пути к вызываемым инструментам, что делает
процесс построения независимым от значения переменной окружения PATH и других общесистемных настроек.
	Однако исользование абсолютных путей также накладывает на разработчика определенные обязательства.Так , при перемещении каталога проекта или каталога построения в файловой системе приходится заново генерировать
файлы повтроным запуском cmake.Понимание принципа использования абсолютных путей позволяет избежать многих типичных ошибок при использовании cmake в качестве системы построения проекта.
	Синтаксис
	Команды
	Программа на cmake состоит из последовательности команд, исполняемых интерпритатором.Синтаксис команды:
	<имя команды>([<аргумент1>...<аргумент2>])
	Замечание:аргументы команд разделяются символами-разделителями, а не запятыми.
	В качестве символа-разделителя могут использоваться один или несколько пробелов, символ табуляции и перевода строки.Таким образом, в отличие от make, qmake и тд при записи длинной команды в несколько строк
не нужно завершать каждую из них символом \.
	Языком поддерживаются однострочные комменты, начинаюзиеся с символа #.Также, начиная с cmake 3.0, поддерживаются блочные комменты между символами #[[ и ]]
	Команды являются единственным средством в языке, при помощи них, например, записываются все управляющие конструкции

if(WIN32)
	message(STATUS "Building for windows")
endif()

Замечание:все инструкции, включая endif() в примере выше, являются командами, поэтому после них необходимо ставить скобки.
	Как правило,команды поддерживают переменное количество аргументов
	Строки
	Аргументами команд являются строки.Как и в языках make и тд строки-это последовательности символови escape-последовательностей.Чтобы включить в строку символ-разделитель, можно заключить ее в двойные кавычки.В этом случае
интерпритатор будет считать данне символы частью строки, а не разделителем аргументов.Строки в кавычках могут занимать несколько строк в тексте программы, при этом символ \ в конце строки текста приводит к тому что следующий за ним
символ перевода строки не будет считаться частью строки.
	Пример
message(
	"AB\nCD
	\tEF\
	GH \${DATA}\"\\#"
	)
выведет на консоль:
AB
CD
	EF GH ${DATA}"\#

-Команда выполняет первый перевод строки после символов AB, так как в строковой константе после них указан escape-символ \n
-следующий перевод строки после CD указан в строке явно
-следующая строка начинается с \t, символ перевода строки после EF подавляется символов \ в конце строки.Таким образом,после символа EF на печать выводится два пробела и смиволы GH
-за символами GH выводится пробел, так как он считается частью строки, ограниченной двумя кавычками.
-дальше выводится символы ${DATA}.Если бы в строковой константе перед $ не было бы escape-символа \, конструкция ${DATA} внутри строковой константы считалась бы ссылкой на переменную с именем DATA и была бы заменена ее значением.
	Хотя все данные в cmake имеют строковый тип, в некоторых слуаях строковые значения служат в качестве  данных другого типа.Так, строки используются для представляения чисел в десятичной записи-как целых, так и с плавающей точкой.
Формат записи аналогичен другим яп.
	При использовании управляющих конструкций необходим способ представления логических значений.Для этого могут быть использованы различные строковые значения

TRUE FALSE
YES NO
Y N
ON OFF
0 IGNORE NOTFOUND " "
	Запись всех именованных логических констант нечувствительна к регистру.Значения, заканчивающиеся на -NOTFOUND, можно использовать для проверки результатов успешност поиска файлов, библиотек и тд при помощи команд find_file(), find_library() и тд
которые записывают путь к найденному объекту в заданную переменную.Если поиск закончился неудачей, эти команды записывают в переменную ее имя, дополненное суффиксом -NOTFOUND.
	Другим типом данных, поддерживаемых языком cmake, является список.Списки представляются пр помощи обычных строк, внутри которых символы ; раделяют соседние элементы.Перебор элементов списка можно выполнять при помощи команд foreach() и endforeach().
При передаче списков в команды в качестве аргументов их элементы передаются внутрь команд несколькими аргументами вместо одного.Чтобы заставить команду воспринимать список как один аргумент, его можно поместить в двойные кавычки.
	пример
message(a;b;c;)
message("a;b;c")
	вывод
abc
a;b;c

	Здесь первая команда message() получит три аргумента a,b и c. Команда выводит свои аргументы друг за другом без пробелов.Вторая команда message() получит один аргумент строку a;b;c

	Переменные
	Так же как и в языке burn shell и тд в cmake есть поддержка переменных строкового типа.Значения переменных могут использоваться внутри аргументов команд при помощи конструкции ${VAR_NAME}

	пример

set(GREETING Hello)
message("${GREETING} world!")

	Здесь переменной GREETING присваивается значение Hello, после чего выводится сообщение Hello world!
	Кроме пользовательских переменных в cmake также существует множество встроенных, имеющих специальное назначение.
	Имена переменных чувствительны к регистру и могут состоять почти из любых символов.
Замечание:при обработке проектов система cmake создает переменные с именами вида <имя_проекта>_SOURCE_DIR.Более свободные по сравнению с другими яп правила именования переменных позволяют накладывать
ограничения на названия проектов.Например имя 01-hello_SOURCE_DIR является допустимым, хотя лексический анализиатор большенства яп мог бы воспринять его как арифметическое выражение
	Как и в других яп, переменные имеют облатсь действия.Области действия определяются следующими сущностями:
1.Ф-ция.Ф-ции cmake определяют пользовательские команды, которые могут использовать локальные перменные.Ф-ции определяются при помощи команд function() и endfunction()
2.Каталог (под)проекта.Каждый обрабатываемый каталог исходных файлов со своим описанием CMakeLists.txt задает собственную область действия переменных.Перед началом обработки подпроекта с собственным файлом
CMakeLists.txt система CMake копирует в новую область все переменные из продительской области.Сценарии, запучскаемые cmake -P ... также задают область действия.
3.Кэш.Некоторые переменные могут быть определены в программе как предназначенные для постоянного хранения в файле CMakeLists.txt, записываемом  в выходной каталог.Эти переменные будут сохранять свои значения
между повторными запусками cmake.Значения переменных можно редактировать,например, при помощи графической утилиты ccmake.Переменные кэша предназначены для хранения изменяемых настроек построения проекта.Первый запуск
cmake заполняет их некоторыми значениями по умолчанию, последующие запуски
Замечания:
-В отличие от подпроектов, подключаемых командой add_subdirectory(),модули cmake, которые подключаются командой include(), отдельной области действяи переменных не образуют
-Область действия также относится и к специальным переменным.То есть их значения и действие ограничиваются текущей областью.Таким образом, статус специальной переменной определяется ее именем.При этом в разных областях
действия могут существовать разные специальные переменные с одним и тем же именем.
-переменные которые создаются в командной строке при выхове инструмента cmake с помощью ключа -D попдают в кэш
	При исполнении команд каждая найденная ссылка на переменную ${VAR_NAME} заменяется ее значением.Поиск значения выполняется от вершины в глубину стека областей действия переменных, образуемого динамически вложенными вызовами ф-ций.
Последней просматривается область действия текущего интерпритируемого файла CMakeLists.txt(если переменная не была найдена ранее), а после нее область кэша.Если переменная нигде не найдена, ссыдка на нее заменяется пустой строкой.
	Для установки значения переменных в cmake используется ряд команд
	Специальная конструкция ENV{<имя переменной>} может быть использована для доступа к переменной окружения работающего процесса cmake.Она может использоваться везде, где можно применить обычные переменные(не кэша).Доступ к значению переменной
окружения осуществляется пр помощи $ENV{<имя переменной>}
	пример
set(ENV{PATH} "$ENV{PATH};${CMAKE_BINARY_DIR}")
	Здесь при помощи команды set() к переменной окружения PATH добавляется через точку с запятой путь к каталогу построения проекта верхнего уровня, который хранится в специальной переменной CMAKE_BINARY_DIR.Переменная окружения PATH в различных
системах содержит список каталогов, в которых осуществляется поиск, в частности, исполняемых файлов при указании их имени в командной строке
Замечания:
-В разных системах пути в переменной окружения PATH могут отделяться друг от друга разными символами.В POSIX совместимых системах для этого используется двоеточие
-Выполненное в примере выше изменение переменной окружения, унаследованной процессом cmake от родителя, будет действительно только для этого процесса на время его работы.Оно не повлияет на значение этой переменной для родительского процесса или процессов, которые
будут в дальнейшейм выполнять построение проекта.Чтобы установить значения переменных окружения для инструментов, которые запускаются во время исполнения правил, определяемых командами add_custom_target() и add_custom_command(),можно воспользоваться командой
cmake -E env...
-cmake выдвигает те же требования к именам переменных окружения, что и для своих переменных.В частности, в именах переменных недопустимы скобки.Это затрудняет использование переменной окуржения ProgramFiles(x86), определенной в 64-битной системе
	Свойства
Свойства аналогичны переменным, но относятся к различным объектам:
-каталогам проектов (как каталогам верхнего уровня, передаваемым cmake в качестве аргумента командной строки,так и подключаемым при помощи команды add_subdirectory().
-целям
-тестам
-исходным файлам
-переменным, хранящимся в кэше
-файлам для установки
	Также существуют глобальные свойства.Как и переменные, свойства могут быть стандартными(имеющими определенное назначение).Изменение таких свойств приводит к определенным изменениям в генерируемой системе построения.В дальнейшем стандартные свойства будут
рассматриваться по мере необходимости.Некоторые стандартные свойства доступны только для чтения.Таким образом, можно провести аналогию между свойствами cmake и свойствами классов в ооп
	Для считывания и установки значений свойств используеются коанды get_property() и set_property()
Замечание:в отличие от переменных, которые имеют области действия, свойства всегда связаны с объектами, для которых они определены.Например, глобальное свойство с заданным  именем всегда существует в единственном экземпляре, в то время как одновременно может существовать
сразу несколко переменных с одним именем а разных областях действия.
	Примеры построения простых проектов
	Прежде чем приступать к изучению основных команд cmake, рассмотрим несколько примеров его использования
Пример
Пусть требуется построить проект из одного файла, в результате чего должен быть создан исполняемый модуль.Рассмотрим возможную структуру каталогов проекта на рисунке catalog_topology.png.Здесь в некоторой рабочей папке находятся каталог исходников(test_cmake) и каталог построения (build_catalog_for_test)
В этом примере оба каталога расположены рядом друг с другом для упрощения команды вызова cmake
	Для решения задачи в каталоге проекта должен содержаться файл CMakeLists.txt с содержимым которое находится ниже в картинке catalog_topology.png
Первая строка в этом файле является комментарием.Дальше следует команда project(), задающая имя проекта. Это имя будет использовано при создании системы построения в качестве имени решения или основного проекта
	Последняя строка содержит команду add_executable(), которая определяет новую цель построения с именем test_cmake и исходным файлом main.cpp.По умолчанию построение цели должно привести к созданию исполняемого файла с тем же именем, что и имя цели (test_cmake) в выходном каталоге проекта.
	Если в далнейшем необходимо добавить в проект другие исходники, их имена можно добавить в список аргументов команды add_executable().
Для удобства можно создать файл сценария build.cmd/build.sh рядом с каталогом build_catalog_for_test, при помощи которого можно автоматизировать процесс построения вызовом инструмента cmake с нужными аргами.Содержимое этого файла является специфичным для компьютера, на котором выполняется построение.
Пример
Пусть необходимо построить проект содержащий две цели:статическую библиотеку и приложение которое использует эту библу.Файлы в каталоге проекта построены как в папке build2.
	Здесь исходные файлы библиотеки и приложения расположены в двух подкаталогах проектов нижнего уровня,каждый из которых имеет собственный файл описания CMakeLists.txt.Оба проекта объединяются третьим файлом CMakeLists.txt, расположенным на каталог выше, в корне составного проекта.Эти файлы могут иметь следующее содержание
	Файл CMakeLists.txt верхнего уровня:

cmake_minimum_required(VERSION 2.8)
project(lib)
add_subdirectory(sample_lib)
add_subdirectory(sample_prog)

	Файл CMakeLists.txt проекта библиотеки:

add_library(sample_lib sample_mod.cpp sample_mod.h)

	Файл CMakeLists.txt проекта исполняемого файла:

add_executable(sample_prog main.cpp)
include_directories(../sample_lib)
target_link_libraries(sample_prog sample_lib)

	Описание проекта верхнего уровня начинается с команды cmake_minimum_required(), устанавливающей наименьшую версию инструмента CMake, которым может быть обработан проект.
Далее устанавливается название проекта пр помощи команды project().Затем к проекту присоединяются два проекта нижнего уровня пр помощи команд add_subdirectory(), задающих пути к подкаталогам.
	Описание проекта библиотеки содержит единственную команду add_library(), в которой задаются имя цкли и список исходных файлов проекта.Сборка проекта должна привести к созданию статической библы
в выходном каталоге проекта sample_lib(подкаталога sample_lib выходного каталога проекта верзнего уровня).Имя файла библиотеки будет по умолчанию совпадать с именем цели sample_lib с префиксом и расширением,
зависящем от компилятора.Например для компилятора gcc имя библы будет libsample_lib.a.
	Описание проекта приложения отличается от предыдущего добавлением двух новых команд.Команда include_directories() определяет дополнительные пути поиска заголовочных файлов компилятором.В подкаталоге sample_lib
находится заголовок sample_mod.h с описаниями, необходимыми для использования библиотеки.Исполнение команды include_directories() приводит к тому, что в генерируемом проекте команда для компляции исходных файлов проекта
sample_prog будет содержать аргумент командной строки передающий компилятору путь к каталогу sample_lib.Например, для компилятора gcc это будет ключ -I с путем:
gcc ... -I<путь к sample_lib>...
	Таким образом, исходных файлах проекта приложения можно использовать следующую директиву:

#inlude "sample_mod.h"

вместо

#include "../sample_lib/sample_mod.h"

	Наконец, команда target_link_libraries() определяет зависимость цели sample_prog от sample_lib.Кроме того, команда устанавливает, что при построении цели sample_prog будет использоваться библиотека, создаваемая в результате
построения цели sample_lib.
	В заврешении осталось рассмотреть вопрос о том, каким образом можно указать системе cmake, что при построении цели sample_lib необходимо создать статическую библу, как требуется по условию.Дело в том, что по умолчанию команда add_library() может
приводить к генерированию правил для создания динамической библы.Сборка цели в виде статической библы можно добиться тремя способами:
1.Можно при вызове cmake в cli определить значение специальной переменной BUILD_SHARED_LIBS как FALSE:
cmake -G "..." -D BUILD_SHARED_LIBS = 0 ../lib
	Здесь в качестве значения по умолчанию можно указать любую строку, означающую ложь.Таким образом, тип библы можно определить в cli
2.Если необходимо построение стстик библы в люом случае, можно упростить команду вызова cmake, выполнив нужное присваивание прямо в тексте описания проекта:
set(BUILD_SHARED_LIBS FALSE)
	Эту команду можно вставить в файл CMakeLists.txt проекта верхнего уровня или проекта библы.Она повлияет на поведение всех команд add_library(), исполняемых после нее в текущей области действия переменной BUILD_SHARED_LIBS.
3.Наконец, тип библы можно указать приямо в команде add_library(), передав ей аргумент STATIC:

add_library(
sample_lib STATIC
sample_mod.cpp
sample_mod.h)

	Эта настройка будет влиять только на данную цель.

	Команды общего назначения

	cmake_minimum_required()
cmake_minimum_required(VERSION <версия> [FATAL_ERROR])
	Команда определяет минимальную версию инструмента cmake, при помощи которого можно обрабатывать текущий входной файл проекта.Аргумент <версия> может содержать до 4 чисел, разделенных точками.
	Если версия cmake окажется ниже заданной, обработка файла остановится с сообщением об ошибке.
-Необязательный аргумент FATAL_ERROR имеет значение для версии cmake 2.4 или ниже-с ним команда приведет к останову с ошибкой вместо обычного рпедупреждения
	Команда в соответствии с номером версии также устанавливает политику совместимости-набор аспектов поведения cmake, делающий его совместимым с рпедыдущей версией.Множество аспектов поведения cmake может
меняться от версии к версии.Явное указание политик совместимости желательно, поскольку обеспечивает корректную обработку описанний проектов при переходе на новую версию cmake.
	cmake_minimum_required() рекомендуется указывать самой первой в файле CMakeLists.txt верхнего уровня.Если команда еще не исполнялась и cmake требуется выполнить действие, зависящее от политики совместимости,
он выведет предупреждение.
	project()
	project(
		<имя проекта>
		[VERSION <версия>] [LANGUAGES <язык1>...<языкn>])
	Команда устанавливает имя для иерархии проектов.Например, для генераторов microsoft VS это имя определяет имя создаваемого решения
-После необязательного аргумента VERSION можно указать версию проекта-строку до 4 чисел, разделенных точками(по умолчанию ставится пустая строка).Установка версии проекта доступна начиная с cmake 3.0
-После необязательного аргумента LANGUAGES указываются яп, для которых обеспечивается поддержка в проекте.По умолчанию установлен c/с++.Если после арга LANGUAGES добавить NONE, поддержка всех языков будет отключена.
Если в project() не определена версия проекта, аргумент LANGUAGES можно пропустить.Передача арга LANGUAGES доступна в cmake 3.0+
	Команда устанавливает значения нескольким специальным переменным CMake
	Некоторые переменные, устанавливаемые командой project)(
	имя переменной 					значение
	PROJECT_NAME					имя проекта, определяемое командой
	PROJECT_SOURCE_DIR				полный путь к каталогу проекта верхнего уровня(каталог исходников)
	<имя проекта>_SOURCE_DIR		то же самое
	PROJECT_BINARY_DIR				полный путь к каталогу построения верхнего уровня(каталог выходных и промежуточных файлов)
	<имя проекта>_BINERY_DIR		то же самое
	PROJECT_VERSION					версия проекта, указанная после VERSION
	<имя проекта>_VERSION			то же самое
	Команду project() рекомендуется указывать в файле CMakeLists.txt верхнего уровня.Она должна быть указана в явном виде(не внутри модулей подключаемых include()).
Если ее там нет, система создает проект с некоторым именем по умолчанию.Внутри файлов CMakeLists.txt для подпроектов эту команду имеет смысл указывать, если эти проекты вместе с проектами, от которых для них установлены
зависимости, могут собираться отдельно от остального набора проектов.В этом случае для подпроектов будут сгенерированы отдельные решения, которые будут обрабатываться интегрированной средой гораздо быстрее полного набора(обычно при открытии решений
иде собирает инфу обо всех исходных файлах с целью построения информации для быстрого перехода и тд)
	include()
	include(
	<файл> | <модуль>
	[OPTIONAL] [RESULT_VARIBLE <имя переменной>])
	Загружает из внешнего файла и исполняет заданный модуль cmake.Модуль может задаваться при помощи пути к файлу(включая расширение .cmake, относительный путь определяет местонахождение относительно каталога проекта) либо только именем модуля(без пути и расширения).
В последнем случае файл с именем <модуль>.cmake ищется в каталогах, список которых задан в переменной CMAKE_MODULE_PATH(по умолчанию пустая), и затем в каталоге стандартных модулей, поставляемых с cmake.
-если указан необязательный арг OPTIONAL, исполнение команды include() не приведет к ошибке, если указанный модуль не будет найден.Это может быть полезным в тех случаях, когда какие-то необязательные для построения компоненты проекта не восстанавливаются из репозитория
исходных кодов и не собираются в целых экономии времени
-после RESULT_VARIBLE можно указать имя переменной, в которую будет записан полный путь к найденному модулю или значение NOTFOUND, если модуль не будет найден.Таким образом, можно программно проконтролировать успешность загрузки модуля
	message()
	message([<режим>] <строка1>...<строка2>)
<режим>::= STATUS|WARNING|AUTHOR_WARNING|SEND_ERROR|FATAL_ERROR|DEPRICATION
	Команда предназначена для вывода сообщения различными утилитами cmake, интерпритирующими входной файл.Консольная программа cmake выводти сообщение в стандартный поток вывода при использовании режима STATUS и в стандартный поток ошибок а остальных случаях.Другие утилиты
выводят сообщения в окно журнала, в виде диалоговых окон и тд.
	Выводимое сообщение получается в резульатате конкатенации строк, передаваемых команде
-При помощи первого арга можно указать режим, который влияет на способ отображения сообщения, способ его форматирования, а также дальнейшее поведение cmake.Он может продолжить или прервать обработку входного файла, а также выполнить или пропустить генерацию файлов для конечной системы построения
	режимы выполнения команды message()
режим 				описание 							обработка	генерация
не указан			важная инфа							+			+
STATUS 				обычная инфа						+			+
WARNING 			предупреждение						+			+
AUTHOR_WARNING 		предупреждение для разраба			+			+
SEND_ERROR			локальная ошибка					+			-
FATAL_ERROR			серьезная ошибка					-			-
DEPRICATION			использование устарешвей фишки		зависит от настроек
	При исполнении команды message(DEPRICATION...) поведение cmake зависит от значений специальных переменных CMAKE_ERROR_DEPRECATED И CMAKE_WARN_DEPRECATED.Если первая из них содержит значение истина, поведение аналогично режиму FATAL_ERROR, иначе, если  вторая содержит значений истина-режим WARNING.
Иначе обработка файла и генерация продложаются, и сообщение не выводится.По умолчанию обе переменные содержат значение FALSE
	Команды описания целей
	add_executable()
	add_executable(
	<логическое имя цели>
	[WIN32][MACOSX_BUILD][EXCLUDE_FROM_ALL]
	<исходный модуль1>...<исходный модульn>)
	Команда добавляет к проекту цель с заданным логическим именем, построение которой из уникальных исходных модулей должно привести к созданию исполняемого файла
	Имя исполняемого файла формируется из имени цели и расширения.Изменить имя можно также при помощи установки свойства OUTPUT_NAME цели
	По умолчанию файл должен в подкаталоге построения, соответствующем текущему обрабатываемому подкаталогу проекта.Изменить этот каталог можно при помощи установки соответствующего свойства цели, которое изначально инициализируется значением специальной переменной CMAKE_RUNTIME_OUTPUT_DIRECTORY.Конечные
системы построения, которые поддерживают множественные конфигурации,могут добавлять к этому пути еще один вложенный каталог, соответствующий имени используемой конфигурации
-передача команде необязательного аргумента WIN32 приводит к точу, что при построении для windows приложение не будет иметь создаваемой по умолчанию консоли, даже если главной ф-цией программы является ф-ция main(), а не Winmain().Это достигается передачей компоновщику аргумента cli, зависящего от компилятора.
Например, для системы gcc-MinGW компоновщику передается ключ -Wl, --subsystem, windows.Это бывает удобно, в чатсности для разработки с использованием QT.
	При использовании арга WIN32 можно обойтись без ф-ции Winmain(), таким образом, упростить переносимость кода.Для остальных платформ этот арг игнорируется.
-передача MACOSX_BUILD сообщит системе cmake, что создваемый исполняемый файл должен быть пакетом приложения системы OSX
-передача EXCLUDE_FROM_ALL приводит к тому что генерируемая цель будет исключена из цели all.Таким образом, например, при работе с системой make команда make или make all приведет к построению данной цели, только если от нее зависимы другие цели, включенные в all
Замечание: при использовании компилятора visual c++ передачи аргумента WIN32 команде add_executable() недостаточно, если требуется использовать ф-цию main() в качестве точки входа.В этом случае также требуется передача компоновщику ключа
/ENTRY:mainCRTSartup
	add_library()
1.	add_library(
	<логическое имя цели>
	[STATIC|SHARED|MODULE]
	[EXCLUDE_FROM_ALL]
	<исходный модуль1>...<исходный модульn>)

2.	add_library(
	<логическое имя цели>
	<тип библы>
	IMPORTED)
	<тип библы>::=SHARED|STATIC|MODULE|UNKNOWN

	Первая форма команды add_executable(), но создает цель для построения библы
	Имя библы будет сформировано из базового имени(по умолчанию соответствующего имени цели):например <имя>.lib для visual c++, lib<имя>.a для gcc и тд
	По умолчанию библа будет создана в подкаталоге построения, соответствующем текущему обрабатываемому подкаталогу проекта.Изменить расположение библы можно при помощи установки свойств цели, которые инициализируется значениями специальных переменных.
Как и в случае с командой add_executable(), конечные системы построения могут добавлять к этим поутям каталог с именем используемой конфигурации
	специальные переменные, определяющие выходные каталоги для библа
переменная 								виды библ
CMAKE_ARCHIVE_OUTPUT_DIRECTORY			статик(+импорта)
CMAKE_RUNTIME_OUTPUT_DIRECTORY			DLL
CMAKE_LIBRARY_OUTPUT_DIRECTORY			модули, разделяемые
-типа библ можно задачать пр помощи необязательного арга:
	1.STATIC:статическая
	2.SHARED:динамическая
	3.MODULE: разделяемая, предназначенная исключительно для загрузки при помощи ф-ций api(pisix dlopen() и тд).Такой тип библ испольуется для реализации загружаемых модулей
	По умолчанию создаются правила для построения разделяемой библы,если переменная BUILD_SHARED_LIBS содержит истинное значение,  и статик, если иначе
	Таблица выше нуждается в пояснении.При построении все статические библы помещаются в каталог, определяемый переменной CMAKE_ARCHIVE_OUTPUT_DIRECTORY.Аналогично, все загружаемые модули попадают в каталог, путь к которому задается переменной CMAKE_LIBRARY_OUTPUT_DIRECTORY.
Сложнее с разделяемыми библиотеками.Дело в том что posix-совместимых системах разделяемые библы принято помещать в специальные каталоги-туде же, где находятся и статические библы.При создании
процесса динамический загрузчик исполняемого файла будет искать все требуемые для него библы в этих каталогах.Некоторые из этих путей могут быть заданы системной переменной (переменной окружения LD_LIBRARY_PATH).Другие из этих путей могут храниться в относительном виде в самом
исполняемом файле.Если библы будут расположены в другом месте, загрузчик не сможет их найти.Как правило, исполняемые файлы помещаются в каталог с именем bin, а разделяемые библы -в каталог рядом lib.Таким образом, разделяемые библы помещаются при построении в каталог, путь к которому
задается переменной CMAKE_LIBRARY_OUTPUT_DIRECTORY.
	В системах совместимых с windows динамические библы ищутся загрузчиком прежде всего в тех же каталогах что и исполняемые файлы.Например, динамическая библа может находиться в том же каталоге что и использующая ее программа.По этой причине динамические библы создаются при построении
проекта в таких системах в том же каталоге что и исполняемые модули то есть путь которому находтися в переменной CMAKE_RUNTIME_OUTPUT_DIRECTORY.При этом для облегчения процесса подключения дин библы к использующему ее приложению при ее построении также создается небольшая статическая библа,
содержащая инфу об экспортируемых символах динамической.Как и другие статические библы, библа импорта помещается в каталог путь к которой определяется переменной CMAKE_ARCHIVE_OUTPUT_DIRECTORY.
	Пример в build3
Пусть проект включает исполняемый файл и две библы, соторые он использует.Пусть структура проекта соответствует картинке build3.png
	В этом случае для формирования при построении системы выходных файлов каталогов, совместимой с рекомендациями GNU, можно использовать описание которое дано в описани проекта в каталоге верхнего уровня
	Здесь специальная переменная CMAKE_BINARY_DIR хранит полный путь к каталогу построения проекта верхнего уровня.Вместо нее в этом примере можно использовать переменную CMAKE_CURRENT_BINARY_DIR, в котрой хранится путь к каталогу построения текущего (под)проекта
	В результате обработки этого примера cmake и сборки проекта в windows каталог построения будет иметь структуру как на картинке buil3win.png, а в posix-совместимых системах как на картинке build3pos.png.Как можно видеть,в системе windows все выходные файлы будут помещены в один каталог, так что
при отладке приложения загрузчки сможет найти все требуемые ему библы.То же самое будет справедливо и для posix-систем.
	Вторая форма команды add_library() предназначена для добавления к проекту внешней заранее собранной библы (как правило стронней).Как и для предыдущей формы команды, создается цель с заданным логическим именем, которая по умолчанию имеет область видимости текущего каталога построения и ниже и которую
можно использовать как и остальные цели библиотек, для связывания с другими целями проекта при помощи команды target_link_libraries().Однако в этом случае не создается никаких правил построения библы.Чтобы указать меcтоположение файла библы для создаваемой цели, необходимо записать его в свойство цели IMPORTED_LOCATION,
а также в свойства IMPORTED_LOCATION_DEBUG и тд для каждой используемой конфигурации при помощи set_property().Для получения пути к исполняемому файлу библы можно использовать команду find_library().
	Вообще говоря, использовать дополнительную команду add_library(... IMPORTED) для того, чтобы подключить внешнюю библу, необяхательно, так как команда target_link_libraries() может получить на вход непосредственно пути к файлам библиотек вместо логических имен их целей.Однако команда позволяет существенно упростить повторное
использование библиотеки, поскольку для определяемой ею цели можно настроить свойства, используемые при построении зависимых целей(например, каталоги поиска заголовочных файлов).Таким образом, эти свойства не нужно устанавливать заново для каждой цели, к котрой подключается библа.К сожалению, цель библиотеки, которая определяется
это командой, нельзя передавать первым параметром командам target_link_libraries() и тд.Однако можно устанавливать соответствующие свойства цели командой set_property(), что менее удобно, но все равно не влияет на удобство описания зависимых целей.
	add_subdirectory()
	add_subdirectory(
	<подкаталог проекта>[<подкаталог построения>]
	[EXCLUDE_FROM_ALL])
	Команда добавляет к построению подпроект, расположенный в заданном подкаталоге.В нем должен находиться файл CMakeLists.txt с описанием подпроекта.Имеет смысл указывать относительный путь к каталогу, он будет определен относительно текущего каталога исходных файлов проекта
-При помощи необязательного аргумента <подкаталог ппостроения> можно указать подкаталог для выходных и промежуточных файлов подпроекта.Так же как и подкаталог проекта, он определяется относительно каталога построения текущего проекта.Если этот аргумент пропущен, в качестве него выбирается такой же относительный путь, что и <подкаталог проекта>
-При помощи передачи команде необязательного аргумента EXCLUDE_FROM_ALL можно исключить подпроект вместе со всеми зависимыми проектами из общего построения.При использовании системы make цель будет исключена из цели all.Таким образом, команда make или make all будет выполнять построение этого подпроекта только в том случае, если от него зависят
другие цели, строящиеся вместе с целью all.То же самое относится и к интегрированным средам в случае их использования:подпроект будет включен в общее решение, только если от него зависят другие проекты этого решения.В противном случае имеет смысл использовать команду project() в файле CMakeLists.txt подпроекта.Тогда система cmake создаст отдельное решение для
этого подпроекта и зависимых от него проектов.Обычно таким образом организуется подпроект, не обязательно для общего построения.
	Команды настройки целей
	include_directories()
	include_directories(
	[AFTER|BEFORE][SYSTEM]
	<каталог1>...<каталогn>)
	Команда include_directories() добавляет указанные каталоги к списку каталогов, в которых компилятор должен искать заголовочные файлы, подключаемые директивами #include.Эти каталоги добавляются к соответствующему свойству всех целей, определенных в текущем файле CMakeLists.txt.Относительные пути интерпритируются по отношению к текущему каталогу исходных файлов проекта.
При построении целей эти пути передаются компилятору при помощи аргументов cli, зависящих от конкретного компилятора.Например для gcc каждый путь передается при помощи ключа -I.
	При построении вне каталога проекта бывает необходимо добавить текущие каталоги исходных и выходных файлов к списку каталогов для поиска подключаемых файлов(значения, содержащиеся в переменных CMAKE_CURRENT_SOURCE_DIR и CMAKE_CURRENT_BINARY_DIR).Это бывает необходимо, если в выходном каталоге генерируются промежуточные подключаемые файлы.Добавить эти каталоги можно, установив
значени специальной переменной CMAKE_INCLUDE_CURRENT_DIR в истину
	set(CMAKE_INCLUDE_CURRENT_DIR ON)
-При помощи необязательного аргумента BEFOR, AFTER можно сообщить команде,что заданные в ней каталоги должны добавляться соответственно в начало ил конец списка каталогов для поиска.Если аргумент не указан, каталоги добавляются в начало, если специальная переменная CMAKE_INCLUDE_DIRECTORIES_BEFORE установлена в значение истина.
-При помощи необязательного аргумента SYSTEM можно сообщить, что указанные каталоги являются системными(относящимися к компилятору).Некоторые компиляторы в таком случае обрабатывают такие каталоги с некоторыми отличиями(не генерируют предупреждений, не создают инфу о зависимостях для находящихся в них файлов итд)
	target_link_directories()
	target_link_directories(
	<имя цели>
	[SYSTEM][BEFORE]
	INTERFACE|PUBLIC|PRIVATE
	[<каталог1>...<каталог1,m>]
	[
		INTERFACE|PUBLIC|PRIVATE
		[<каталог2,1>...<каталог2,n>]
	...
	])
	Команда target_link_directories() появлилась в cmake 2.8.11.Результат ее исполнения аналогичен вызову команды include_directories(), основные же отличия состоят в следующем:
-в аргументе команды указывается имя цели, к кторой она относится.Команда влияет на соответствующие свойства этой цели, в то время как команда include_directories() влияет на свойства каталога проекта
-есть возможность указать, будут ли использованы указанные а аргументах команды каталога для компиляции самой цели или зависимых от нее целей
	Перед путями к каталогам указывается один из следующих аргументов:
	PRIVATE:каталоги будут использованы для поиска заголовочных файлов при компиляции файлов текущей цели(аналогично include_directories())
	INTERFACE:каталоги будуи использованы при компиляции файлов зависимых целей от текущей
	PUBLIC:каталоги будут использованы при компиляции файлов как текущей цели, так и зависимых от нее целей(как будто использованы PRIVATE и INTERFACE)

	Таким образом, команда позволяет упростить подключение библиотек к исполняемым файлам
	Пример
Рассмотрим проект, состоящий из библиотеки и использующего ее приложения, аналогичный приведенному в примере на картинке interface.png
	С использованием команды target_include_directories() можно реализовать файлы описания проектов следующих образом:

	cmake_minimum_required(VERSION 2.8.11)

	project(interface)

	add_subdirectory(mylib)

	add_subdirectory(myprog)

	Здесь при помощи первой команды устанавливается минимальная версия cmake, поскольку команда terget_include_directories() появилась там

	Файл проекта библиотеки:

add_library(mylib_ l.cpp l.h)
target_link_libraries(myprog_ mylib_)

	Описание этого проекта упрощается по сравнению с предыдущими похожими примерами, так как в нем больше не нужно использовать команду include_directories().Достаточно лишь установить
зависимости между проектами при помощи команды target_link_libraries()
Замечание:для удобства в cmake есть специальная переменная CMAKE_INCLUDE_CURRENT_DIR_IN_INTERFACE, установка которой в истинное значение приводит к автоматическому добавлению каталога подпроекта
и каталога его построения в список подключаемых путей для зависимых целей.То есть эта переменная аналогична переменной CMAKE_INCLUDE_CURRENT_DIR, которая влияет на построение текущей цели.Таким образом
вызов команды target_include_directories() в примере выше можно заменить на команду:
set(CMAKE_INCLUDE_CURRENT_DIR_IN_INTERFACE ON)
	add_definitions(),add_compile_options()

	add_definitions(
	<определение1>...<определениеn>)

	add_compile_options(
	<аргумент1>...<аргументn>)
	Команда add_definitions() добавляет заданные определения символов препроцессора к свойствам текущего каталога и подчиненных(подключаемых при помощи команды add_subdirectory()).Определения символов должны быть
в формате -D<имя символа> или /D<имя символа>.Система cmake автоматически преобразует такие определения к аргументам командной строки , поддерживаемым используемым компилятором
пример
add_definitions(-DDEBUG -DEXTRA_TESTS)
	При использовании в построении компилятора gcc ему будут переданы аргументы -DDEBUG -DEXTRA_TESTS, а при использовании MVC++ /DDEBUG /DEXTRA_TESTS.После этого в компилируемых файлах препроцессором будут положительно обрабатываться
директивы вида:
#ifdef EXTRA_TESTS
	do_extra_tests();
#endif
	Определения в любом другом формате будут переданы без изменения компилятору в качестве аргументов командной строки.Однако в этом случае предпочтительнее ипользовать команду add_compile_options()(появилась в cmake 2.8.12),которая всегда приводит к
передаче компилятору заданных аргументов в неизменном виде.Так как доступные аргументы cli зависят от используемого компилятора, при их передаче необходимо использовать проверки на тип компилятора при помощи команды if() и специальных переменных, описывающих систему.
Пример
if(MSVC AND MSVC_VERSION GREATER 1400)
	add_compile_options(/MP)
endif()
	Здесь в случае использования компилятора MVC++ версии 2008 или выше ему при компиляции исходных файлов передается аргумент /MP, который приводит к распараллеливанию компиляции на доступное системе число процессорных ядер
Замечание:при использовании инструмента make добиться параллельного выполнения нескольких целей можно при помощи аргумента cli -j<количество процессов>
пример
make -j 8
Замечание:при передаче компилятору аргументов cli, отвечающих за некоторые часто используемые ф-ции, вместо add_compile_options() предпочтительнее использовать другие команды, которые способны передавать компилятору аргументы в поддерживаемом формате:
-для определения символов препроцессора с путсыми значениями предназначена команда add_definitions()
-для передачи компилятору дополнительных путей поиска заголовков предназначена команда include_directories(), которая оказывает влияение на свойства текущего каталога построения, а также команда target_include_directories(), которая определяет свойства определенной цели
-для передачи компоновщику дополнительных библиотек используется команда target_link_libraries().При помощи этой же команды можно передать компоновщику любые аргументы
-для передачи копилятору аргументов, делающих доступными возможности новых стандартов с/с++, используется команда target_compile_features()
-для передачи компоновщику дополнительных путей поиска библиотек используетя команда link_directories().Впрочем в реальных ситуациях эта команда почти никогда не нужна, так как при добавлении библиотек от других целей или найденных при помощи команд find_library() и тд компоновщику будет
передан полный путь к библе.
	target_compile_definitions()
	target_compile_definitions(
	<имя цели>
	INTERFACE|PUBLIC|PRIVATE
		[<определение1,1>...<определение1,m>]
	[
		INTERFACE|PUBLIC|PRIVATE
		[<определение2,1>...<орпеделение2,n>]
		...
	])
	Команда target_compile_definitions() доступна в системе cmake начиная с версии 2.8.11.Эта команда аналогична команде add_definitions(), однако позволяет добавлять определеня символов препроцессора через командную строку вызовов компилятора не только для указанной цели, но и автоматически для всех целей, зависимых от данной,
аналогично команде target_include_directories()
	target_compile_options()
	target_compile_options(
	<имя цели> [BEFORE]
	INTERFACE|PUBLIC|PRIVATE
		[<аргумент1,1>...<аргумент1,m>]
	[
		INTERFACE|PUBLIC|PRIVATE
			[<аргумент2,1>...<аргумент2,n>]
		...
	])
	Команда target_compile_options() доступна cmake начиная с 2.8.12.Эта команда аналогична команде add_compile_options(),однако позволяет передавать аргументы компилятору не только для указанной цели,но и автоматически для всех целей, зависимых от данной, аналогично команде target_compile_definitions()
-при помощи необязательного аргумента BEFORE можно добавлять аргументы компилятора в начало их списка вместо конца(по умолчанию)
	target_compile_features()
	target_compile_features(
	<имя цели>
	INTERFACE|PUBLIC|PRIVATE
		<возможность1>...<возможностьn>)
	Команда target_compile_features() доступна в cmake 3.1.0.Эта команда предназначена для передачи специфических для используемого компилятора аргументов, включающих заданные возможности новых стандартов с и с++.Передаваемые команде возможности должны быть перечислены в специальных переменных CMAKE_C_COMPILE_FEATURES и
CMAKE_CXX_COMPILE_FEATURES.Эти переменные содержат список возможностей, поддерживаемых выбранным компилятором, и являются подмножествами глобальных свойств CMAKE_C_KNOWN_FEATURES И CMAKE_CXX_KNOWN_FEATURES.
-Аргументы INTERFACE, PUBLIC и PRIVATE позволяют передавать ключи компилятора не только для указнной цели, но и автоматически для всех целей, зависимых от данной.Их смысл аналогичен таким же аргументам для команды target_include_directories().
	Если выбранный для построения компилятор не поддерживает указанную возможность, обрабботка описания проекта системой cmake прерывается и генерация файлов для конечной системы построения не вполняется(аналогично команде message(FATAL_ERROR ...)
	Замечание:хотя эта команда появилась в cmake 3.1.0, имеет смысл использовать ее как минимум с cmake 3.3.0, так как в ней стала доступной инфа о возможностях компиляторов gcc, mvc++ и тд.Для более новых компиляторов необходимо использовать более позднюю версию cmake.
	target_link_libraries()
	target_link_libraries(
	<имя цели>[<строка1>...<строкаn>]
	[
		[debug|optimized|general]<строка>
		...
	])
	target_link_libraries(
	<имя цели>
	INTERFACE|PUBLIC|PRIVATE <СТРОКА1>...<строкаm>
	[
		INTERFACE|PUBLIC|PRIVATE <строка1>...<строкаn>
	])
	Команда предназначена для определения подключаемых библиотек к заданной цели или произвольных аргументов командной строки, передаваемых компоновщику
Замечание:имя цели должно быть орпеделено в том же самом каталоге, внутри описания которого вызывается эта команда
	Команда определяет тип аргументов, начиная со второго, по следующим правилам:
1.Если передаваемая строка начинается с символов -l или -framework, то оставшаяся часть строки интерпритируется как имя библы(без префикса lib и расширения)
2.иначе, если передаваемая строка начинается с символа -, она нтерпритируется как аргумент командной строки для компоновщика и во время построения передается ему без изменений
3.Иначе, если строка совпадает с именем другой цели, ранее определенной при помощи команды add_library(), текущая цель будет строиться с испольщованием библы, которая ялвятеся
результатом построения указанной цели.Кроме этого, устанавливается зависимость при построении текущей цели от указанной, аналогично команде add-dependecies()
4.иначе строка должна представлять путь к файлу библы, которая будет использована при построении цели
	Несколько команд target_link_libraries(), последовательно исполняемых для одной и той же цели, добавляют новые настройки к процессу ее компоновки.
	Использование команды также транзитивно переносит на зависимую цель треббоания, определенные для целей связываемых библиотек при помощи интерфейсных аргументов команд target_link_directories() и других, имеющих префикс target_
	Замечание:по умолчанию устанавливаемые отношения зависимости между целями при помощи команды target_link_libraries() ялвяются транзитивными то есть распространяются на зависимые цели.Это может оказаться
нужным при построении приложения, используеющего ф-ции из билы, которая сама использует библы.Даже если библы являются статическими , следовательно, одни библы физически никак не учавствуют в компоновке других библ, они все вместе будут использоваться при
компоновке приложения.
	пример
	в папке build4
-При помощи необязательных аргументов debug, optimized|, general можно ограничить действие следующего аргумента на различных конфигурациях:
debug:следующий аргумент буедет применяться в конфигурации debug и во всех конфигах, перечисленных в глобальном св-ве DEBUG_CONFIGURATIONS
optimized:следующий аргумент будет применяться во всех остальных конфигах
general:следующий аргумент будет применяться во всех конфигах как и в случае когда перед настройкой не указан никакой из этих трех аргов
-Во второй форме команды, появившейся в cmake версии 2.8.12, перед аргами, определяющими подклчаемые библы, можно указать аргументы INTERFACE, PUBLIC, PRIVATE.Они позволяют переопределять стандартное поведение, когда настройки компоновщика транзитивно передаются
зависимым целям.Их смысл аналогичен таким же аргам для команды target_include_directories()
	add_dependencies()
	add_dependencies(
	<имя цели>[<имя цели1>...<имя целиn>])
	Команда устанавливает отношение зависимости при построении заданной цели от других.Команда аналогична команде target_link_libraries() за исключением того, что ее аргументы могут быть только именами целей и что она не устанавливает зависимостей по подключению библиотек в время
компоновки.По сравнению с ней эта команда применяется не так часто.Как правило, она используется при установлении зависимостей для целей, созданных командой add_custom_target()
	Команды обработки данных
	set(),unset(),option()
	set(<имя переменной> [<значение1>...<значениеn>])
	set(<имя переменной><значение>[CACHE<тип><строка описания>[FORCE]]|
	PARENT_SCOPE])
	<тип>::FILEPATH|PATH|STRING|BOOL|INTERNAL
	unset(<имя переменной> [CACHE|PARENT_SCOPE])
	option(<имя переменной><строка описания>[<значение>])
	Первый вариант команды set() предназначен для присваивания заданной переменной списка из заданных значений.Таким образом, переменной будет присвоено значение <значение1>...<значениеn>
	Второй вариант команды set()при указании аргумента CACHE или PARENT_SCOPE предназначен для установки значения переменной в друго области действия.В этом случае переменная не может быть переменной окружения
-При помощи необязательного аргумента CACHE указывается , что команде следует осуществлять присваивание переменной кэша.После этого аргумента указывается тип переменной и строка описания, которая будет использована в качестве информации о переменной в утилите cmake с гуи.Тип переменной
используется исключительно для удобства и влиет на способ редактирования значения переменной, предоставляемой гуи cmake.Возможны следующие значения типов:
	FILEPATH:в переменной хранится путь к файлу.Для редактирования возможно использовать диалоговое окно выбора файлам
	PATH:в переменной хранится путь к каталогу.Для редактирования возможно использовать диалоговое окно выбора каталогам
	STRING:в переменной хранится строка общего назначения.При редактировании используется обычное поле ввода строки
	BOOL:в переменной хранится логическое значение.Для редактирования будет использовано поле выключателя
	INTERNAL:утилита cmake не будет отображать инфу об этой переменной.Предполагается, что переменная используется для внутренних целей и должна храниться в кэше
После строки описания может быть указан необязательный аргумент FORCE.Его использование приводит к тому,что переменной будет присвоено значение в люом лучае, даже если она уже находтися в кэше.По умолчанию, если переменная уже там есть, присваивания не происходит.Такое поведение команды set()
подходит в большенстве случаев,так как позволяет сохранять ранее отредактированные значения кэша.Также при присваивании будет удалена из текущей области действия переменная с тем же именем.
-при помощи необязательного аргумента PARENT_SCOPE указывается, что следует осуществляеть присваивание переменной родительской области действия
	Команда unset позволяет удалить информацию о заданной переменной(cmake или окружения) то есть вернуться к состоянию до первого ее присваивания.Как и для предыдущей команды, необязательные аргументы CACHE и PARENT_SCOPE позволяют указать, к какой области действия следует применить команду.
	Команда option() аналогична команде set() с аргументами CACHE BOOL.По умолчанию переменной устанавливается значение OFF.
	Замечание:так как кэщ представляет собой отдельную область действия переменных, в нем могут храниться переменные с теми же именам, что и у переменных других областей.При этом такие переменные с одним именем будут разными
	Пример в каталоге build5/example1/
	При исполнении фрагмента кода в CMakeLists.txt выведутся следующие строки:
value 2
value 1
	Этот вывод демонстрирует принцип поиска переменных в различных областях действия.Превая команда message() обращается к переменной в текущей области действия.После удаления этой переменной вторая команда message() уже обращается к переменной кэша.
	Однако если в этот фрагмент внести небольшое изменение, входной файл с изменением находится в build5/example2
то в этом выводе cmake будет таким:
value 2
value 2
	Такой вывод происходит потому, что как было отмечано выше, вторая команда set() удаляет из текущей области переменную с тем же именем.При этом unset() попытается удалить инфу об уже не существующей переменной текущей области.
	math()
	math(EXPR <имя переменной> <выражение>)
	<выражение>:=<целочисленный_литерал>|
	(<выражение>)|
	<выражение> <операция> <выражение>

	<целочисленный литерал>:=
	<цифра>...<цифра>

	<операция>:=
	+,-,*,/,%,|,&,^,~,<<,>>

	Эта команда позволяет вычислить фрифметическое выражение и присвоить строковое представление его результата заданной переменной.Поддерживаются целочисленные операнды и бинарные операции, аналогичные языку С.
	Замечания:
-так как унарные операции командой не поддерживаются, выражения вида -4+1 являются неправильными с ее точки зрения.Для представления отрицательных чисел следует вычитать положительные литералы из нуля.
-при использовании пробелов внутри выражения его необходимо заключить в кавычки.
	list()
	Команда list() реализует основные алгоритмы работы со списками.Команда введена для удобства:ее использование необязательно,все задачи, которые она выполняет, можно решить другими средствами.Однако для сокращения
исходного текста описания проектов и для придания ему большей ясности рекуомендуется использовать эту команду там, где это возможно.
	Также как и set(), list() может создавать новые переменные.Однако она создает их всегда в текущей области действия, в отличие от set(), для которой можно указать аргументы CACHE, PARENT_SCOPE.Таким образом, новый список
создается в текущей области действия, даже если исходный список находится в другой области.Чтобы скопировать полученное значение в исходную облатсь, можно использовать команду set()
	Пример в каталоге build6
	Фрагмент кода в CMakeLists.txt выведет на печать a;b;c;d;e;f.Сначала в нем определяется команда test() при помощи команд function()/endfunction().Далее коменда set() присваивает значение переменной TEST_LIST.После этого
исполняется команда test(), которая добавляет в конец списка три хначения.В результате создается переменная с тем же именем TEST_LIST, но уже в области действия ф-ции.Чтобы скопировать значение этой переменной в исходную область действия,
используется команда set() с аргументом PARENT_SCOPE.
	При обращении к элементам списков можно использовать неотрицательные индексы 0,1,2,... для обращения к первому, второму и тд элементу с начала или -1,-2,... для обращения к первому, второму и тд с конца.
Замечание:пр передаче командам значений индексов вне диапазона элементов списка выводится сообщение об ошибке.Выполнение команд продложается, но генерирование файлов конечной сисетемы построения не происходит(как при message(SEND_ERROR...))
list(LENGTH <имя списка> <имя переменной>)
	Эта форма команды записывает в переменную длину списка
list(GET <имя списка><индекс1>...<индексn><имя переменной>)
	Эта форма команды записывает в заданную переменную список из значений исходного списка с заданными индексами
list(APPEND <имя списка> [<значение1>...<значениеn>])
	Эта форма команды дописывает в конец заданного списка заданные значения.Команда равносильна:
set(<имя списка> ${имя_списка} [<значение1>...<значениеn>)

list(FIND<имя списка><значение><имя переменной>)
	Эта форма команды находит в списке заданное значение и возвращает индекс его певрого вхождения(-1 при отсутствии)
list(INSERT <имя списка><индекс>[<значение1>...<значениеn>)
	Эта форма команды вставляет в заданную позицию списка заданное значение
list(REMOVE_ITEM <имя списка> <значение1>...<значениеn>)
	Эта форма удаляет из списка все схождения заданных значений
list(RMOVE_AT <имя списка><индекс1>...<индексn>)
	Эта форма удаляет из списка все элементы с заданным индексом(в исходном списке)
list(REMOVE_DUPLICATES<имя списка>)
	эта форма удаляет из списка все одинаковые элементы кроме их первых вхождений
list(REVERSE <имя списка>)
	эта форма меняет в списке порядок его элементов не противоположный
list(SORT <имя списка>)
	эта команда сортирует элементы списка по возрастанию в лексикографическом порядке
	string()
	Команда string() реализует основные алгоритмы обработки строк:выделение подстроки, поиск, замену и тд.В отличие от других языков,
в cmake нет средства для индексации отдельных элементов строк как массивов, поэтому команда string() ялвяется единственным доступным способом
анализа и изменения их содержимого.
string(<унарная операция> <строка> <имя переменной>)
<унарная операция>::=
	LENGTH|TOLOWER|TOUPPER|STRIP
-команда вызыванная с LENGTH, записывает в заданную переменную длину заданной строки
-команда с TOLOWER/TOUPPER записывает в переменную заданную строку в нижнем/верхнем регистре
-команда с STRIP записывает в переменную подстроку исходной строки без ведущих и завершающих пробелов
string(CONCAT <имя переменной> [<строка1>...<строкаn>])
	Команда string(CONCAT...) выполняет конкатенацию нескольких строк, записывая результат в заданную переменную.Таким образом эта команда позволяет легко преобразовывать
список в строку без разделителей(<<;>>)
string(FIND <строка> <подстрока> <имя переменной> [REVERSE])
	Команда string(FIND...) выполняет поиск в строке первого(или последнего, если используется REVERSE) вхождения подстроки, записывая индекс ее начала в заданную переменную.Позиция
в строке нумеруется с 0, при отсутствии подстроки возвращается -1
string(SUBSTRING <строка> <начало><длина><имя переменной>)
	Команда string(SUBSTRING...) выделяет из строки подстроку, начинающуюся с заданной позиции , заданной длины (или до конца, если в качестве длины указано -1), записывает результат в заданную переменную
string([REGEX]REPLACE <выражение поиска> <выражение замены> <имя переменной><строка1>...<строкаn>)
	Команда string(REPLACE...) выполняет замену всех выхожденй заданной подстроки, которая передается ей чез аргумент <выражение поиска>, на строку, которая передается через аргумент <выражение замены>, в строке,
являющейся конкатинацией строк, которые передаеются команде через последние аргументы.Измененная строка записывается в заданную переменную.
	Команда string(REGEX REPLACE...) работает аналогично, однако рассматривает свой аргумент <выражение поиска> как регулярное выражение , в выражение <выражение замены>-как выражени езамены, в котором могут встречаться
ссылки на части найденных подстрок(<<\<номер>>)
	string(REGEX <операция> <выражение поиска> <имя переменной> <строка1>...<строкаnЮ)
	<операция>::=MATCH|MATCHALL
	Команда string(REGEX MATCH ...) выполняет поиск первого вхожденя подстроки, удовлетворяющей заданному регулярному выражению, в строке, являющейся конкатинацией заданных строк.Найденная подстрока записывается в переменную.
Как и в предыдущей форме команды, выполняется выделение наиболее длинной подстроки, насколько это возможно.Если подстрока не найдена, возвращается пустая строка
	Команда string(REGEX MATCHALL...) работает аналогичным образом, но находит все возможные подстроки, соответствующие регулярному выражению, и возвращает их в виде списка
	Команды управляющих конструкций
	if(),elseif(),else(),endif()
	if(<условие1>)
		<команды>
	[
		elseif(<условие2>)
			<команды>
		...
	]
	[
		else()
			<команды>
	]
	endif()

	<условие>::=
		(<условие>) |
		NOT <условие>|
		<условие> AND <условие>|
		<условие> OR <условие> |
		<логическая константа> |
		<имя переменной>	   |
		<операция><путь>	   |
		<путь> IS_NEWR_THAN <путь> |
		<значение><бинарная операция><значение> |
		<значение> MATCHES <регулярное выражение> |
		COMMAND <имя> |
		TARGET <имя>  |
		DEFINED <имя переменной>

		<значение>::=
			<имя переменной>|<строка>

		<операция>::=
			EXISTS | IS_DIRECTORY | IS_SYMLINK | IS_ABSOLUTE

		<бинарная операция>::=
			LESS | GREATER | EQUAL | STRLESS | STRGREATER | STREQUAL | VERSION_LESS |
			VERSION_GREATER | VERSION_EQUAL
-команда if() вычисляет логическое выражение, которое составляет ее аргументы.Если его значение истинно, исполняются команды от текущего if() до первой соответствующей ей else(), elseif() или endif()
-иначе следующая команда elseif() проверяет условие.Если оно истино , исполняются команды до следующей elseif() и тд
-если все условия в if() и elseif() оказываются ложными, исполняются команды между else() и endif()
-Наличие команд elseif() и else() необязательны.Одной команде if() может соответствовать несколько команд elseif()
	Вычисление выражений происходит следующим образом:
	-скобки и операции OR, AND NOT имеют ту же семантику, что и в других яп
	-строка, соответствующая одному из значений логических констнат таблицы на картинке 2.1.png, интерпритируется в соответствии с этой таблицей.Названия логических констант нечувствительны к регистру
	-иначе строка интерпритируется как имя переменной.Выражение считается истинным, если в этой переменой не содержится значение ложь в соответствии с картинкой 2.1.png
	-также выражением может состоять из нескольких значений со строковыми обозначениями операций.Имена переменных в выражениях (<имя переменной>) эквивалентны их подстановкам :${имя переменной}.Гарантируется, что операции с путями будут давать правильные 
	результаты для абсолютных путей.
	Операции в логических выражениях(таблица 2.6)
	операция 			значение
				унарные 
	EXISTS				проверка того, является ли указанная строка путем к существующему файлу или каталогу в файловой системе
	IS_DIRECTORY 		проверка того, является ли указанная стока путем к существующему каталогу в файловой системе
	IS_SYMLINK			проверка того, является ли указанная строка путем к существующей символической ссылке в файловой системе
	IS_ABSOLUTE			проверка того, является ли указанная строка полным путем в файловой системе
	COMMAND				проверка того, является ли указанная строка именем команды cmake, макроса или ф-ции(определенной при помощи команды function())
	TARGET 				проверка того, является ли указанная строка именем цели (определенной при помощи add_executable())
	DEFINED 			проверка того, является ли указанная строка именем переменной с ранее установленным значением
			бинарные
	LESS,EQUAL,GREATER  аргументы операций интегрируются как десятичная запись с плавающей точкой вещественных чисел.Выполняется проверка того, является ли первое число меньше, равным или больше второго
	STRLESS,STREQUAL,	
	STRGREATER 			проверка того, является ли первая строка лексиграфически меньше, равной или больше второй
	VERSION_LESS,
	VERSION_EQUAL,
	VERSION_GREATER		аргументы операций интерпритируются как номера версий, содержащие до трех точек.Выполняется проверка того, является ли первый номер меньше, больше или равен второму
	MATCHES				проверка того, соответствует ли строка заданному регулярному выражению
	IS_NEWER_THAN		проверка того, является ли время изменения первого файла или каталога больше или равным времени изменения второго.Выражение истинно также в том случае, когда какой-либо из двух файлов или каталогов
						не существует в файловой системе.Таким образом , эта операция подходит для проверки зависимости между файлами во время построения проекта 
	Для операций установлены следующие приоритеты в порядке убывания:
1)унарные; 2)бинарные; 3)NOT; 4)AND; 5)OR
	Чтобы избежать неоднозначности, строки в выражениях можно указывать в кавычках.В этом случае они не будут интерпритироваться как имена переменных или операций.
	Основной областью применения команды if() является организация передачи различных настроек компилятору, компноновщику и тд.В зависимости от целевой ос и компиля.Для этого существует ряд специальных переменных cmake,доступных 
только для чтения, значения которых зависят от используемой среды(картинки 2.7.png, 2.8.png и 2.9.png)
	
	Логические переменные для тестирования целевой ос:
	APPLE*	UNIX**	WIN32
	WINC	WINDOWS_PHONE	WINDOWS_STORE
	*OS X
	**Переменная содержит истину для всех UNIX-подобных систем, таких как системы, основанные на ядре linux,os x, windows с набором инструментов cygwin и тд
	
	Логические переменные для тестирования используемого компилятора и окружения
константа					значение 
BORLAND						любой компиль фирмы borland/embarcadero
CMAKE_CL_64					64-битный компиль microsoft
CMAKE_COMPILER_IS_GNUCC		любая реализация компилятора gcc c
CMAKE_COMPILER_IS_GNUCXX	любая реализация компилятора gcc c++
CYGWIN						реализация cmake для cygwin
MINGW						реализация компилятоора mingw для windows
MSVC						microsoft c++ любой версии 
MSVC_IDE					microsoft c++ ide с проектами для среды microsoft vs в отличие от использования компилятора из CLI
MSVC60						VS C++ 6.0
MSVC70 						VS C++.NET 2002
MSVC71						VS C++.NET 2003
MSVC80						VS C++ 2005
MSVC90						VS C++ 2008
MSVC10						VS C++ 2010
MSVC11						VS C++ 2012
MSVC12						VS C++ 2013
MSVC14						VS C++ 2015
MSYS						реализация компилятора mingw с make-файлами для оболочки MSYS
WATCOM						компилятор open watcom для windows
	
	Переменные, хранящие версии компилятора 
MSVC_VERSION			XCODE_VERSION
	
	Значения переменной MSVC_VERSION соответствует значениям макроса _MSC_VER компилятора vs c++.Эти значения соответствуют первым двум компонентам версии компилятора и не совпадают с номером версии VS (картинка 2.10.png)
	
	Значения переменной MSVC_VERSION
Константа 				значение 
1200					vs c++ 6.0
1300					vs c++.NET 2002
1310					vs c++.NET 2003
1400					vs c++ 2005
1500					vs c++ 2008
1600					vs c++ 2010
1700					vs c++ 2012
1800					vs c++ 2013
1900					vs c++ 2015
	
	Например, в vs 2015 версия компилятора имеет два старших компонента, равных 19.0
	Переменная XCODE_VERSION содержит номер версии среды xcode, например 3.1.2
Пример
Следующий код, будучи помещенным в файл CMakeLists.txt корневого проекта, выполняет аварийный останов cmake в случае, если пользователь пытается зупустить построение проекта в том же каталоге, где находятся его исхдники:

cmake_minimum_required(VERSION 3.10)
set(MY_STR1 "hello")
set(MY_STR2 "hello")
if(MY_STR1 STREQUAL MY_STR2)
        message("str1 equal str2")
else()  
        message("string is not equal")
endif() 

if(CMAKE_SOURCE_DIR STREQUAL CMAKE_BINARY_DIR)
        message(
                FATAL_ERROR
                "Use build directory different fromsource directory")
endif()
	
	Для определения путей к каталогам проекта и построения используется тот факт, что система cmake хранит все пути в абсолютном представлении.Команда message() с аргументом FATAL_ERROR выполняет 
прерывание обработки проекта.Замечание:продемонстрированная в примере проверка может быть особенно полезной, если в результате построения в выходном каталоге генерируются файлы с именами, совпадающими
с именами исходных файлов.
	while(),endwhile(),break(),continue()
	while(<условие>)
		<команды>
	endwhile()
	break()
	continue()
	Команда while() вычисляет условие по таким же правилам, что и if().Пока это условие истинно, выполняются до команды 
endwhile()
	Команда break() досрочно прерывает выполнение ближайшего цикла while() и foreach()
	Команда continue(), появилась в cmake 3.2, досрочно переходит к следующей итерации ближайшего цикла.
	foreach(), endforeach()
	
	foreach(<имя переменной> <значение1>...<значениеn>)
		<команды>
	endforeach()
	
	foreach(
		<имя переменной> IN
		[LISTS [<список1>...<списокn>]]
		[ITEMS [<значение1>...<значениеn>]])
	
	foreach(<имя переменной> RANGE <максимум>)
	
	foreach(<имя переменной> RANGE <старт> <стоп> [<шаг>])
	
	Первая форма команды foreach() выполняет все команды до команды endforeach() в количестве ращ, равном соличеству передаваемых ей значений.При этом на каждой итерации цикла переменная с заданным именем будет принимать значения со второго по последний аргумент команды foreach()
	Вторая форма команды foreach() аналогична первой, но удобнее нее в определенных случаях.В ней можно указывать имена переменных списков, значения которых будут обходиться в цикле(после необязательного аргумента LISTS), а также сами значения непосредственно(после необязательного аргумента ITEMS).
Пустые списки рассматриваются как списки без элементов
	Третья форма команды foreach() выполняет тело цикла с целочисленными значениями переменной от 0 до заданного максимума.Таким образом, тело цикла выполняется максимум+1 раз.
	Наконец последняя форма foreach() выполняет тело цикла с целочисленными значениями переменной в заданном отрезке с заднным шагом (1 по умолчанию).Тело цикла выполняется, пока значение переменной не превышает значения <стоп>.Таким образом, цело цикла будет выполнено всего (<стоп>-<старт>+1)/шаг раз
Пример
Пусть проект верхнего уровня должен состоять из нескольких независимых подпроектов.Требуется организовать схему, предусматривабющую возможность исключения каждого подпроекта из общего построения в целях экономии времени разрабов, которым для работы не нужно собирать все компоненты системы.Компонент выбирается для построения, 
если дерево его исходных файлов загружается из отдельного репозитория кода в каталог корневого проекта.В каждом таком проекте есть еще описание в файле CMakeLists.txt. Кроме этого, разраб может исключать проект из построения при помощи файла настройки из кэша cmake.
	Файл CMakeLists.txt корневого проекта может быть реализован так:

cmake_minimum_required(VERSION 2.8)

project(complex_project)
set(SUBPROJECTS program1 program2 super_program)

include(build.cmake)

	Здесь для удобства разрабов все детали реализации перенесены во вспомогательный файл buil.cmake, который подключается командой include().Таким образом, корневой CMakeLists.txt, который, скорее всего, придется редактировать чаще, имеет небольшой размер.Список компонент присваивается переменной SUBPROJECTS при помощи команды set()
	Файл build.cmake может иметь следующее содержимое:

foreach(PROJ ${SUBPROJECTS})
set(MY_BUILD_${PROJ} TRUE
        CACHE BOOL "build the ${PROJ} subproject")
if(MY_BUILD_${PROJ} AND EXISTS
                "${CMAKE_SOURCE_DIR}/${PROJ}/CMakeLists.txt")
        message(STATUS "The project ${PROJ} will be included")
add_subdirectory(${PROJ})
else()
        message(STATUS "The project ${PROJ} will be included")
add_subdirectory(${PROJ})
else()
        message(STATUS 
                "The project ${PROJ} will not be included")
endif()
endforeach()

	Здесь команда foreach() организует перебор значений списка из переменной SUBPROJECTS, присваивая каждое из них последовательно переменной PROJ.В теле 
цикла при помощи команды set() создается логическая переменная в кэше(если на текущий момент ее там еще нет), значение которой орпеделяет включение подпроекта в построение.Имя переменной 
получается конкатинацией строки MY_BUILD_ и имени подроекта.Далее команда if() проверяет условие, при котором подпроект будет включен в построение.Для этого необходимо, чтобы значение соответствующей переменной 
было истинным и чтобы исходные файлы подроетка были загружены в дерево корневого проекта.Последнее проверяется существованием файла CMakeLists.txt в каталоге с именем подроекта, который должен находиться в каталоге 
корневого проекта.Путь к нему содержится в специальной переменной CMAKE_SOURCE_DIR.Подпроект подключается командой add_subdirectory()
	Команда foreach() может быть также записана в следующем виде:
foreach(PROJ IN LISTS SUBPROJECTS)
	После первой обработки проекта системой cmake будет создан файл кэша в каталоге построения с переменными MY_BUILD_program1 и тд.Дальше включене отдельных компонентов в построение можно настроить, например, при помощи утилиты 
cmake с гуием.
	function(), endfunction(), return()
	function(<имя ф-ции> [<параметр1>...<параметрn>])
		<команды>
	endfunction()
	
	return()
	Команда function() запоминает все команды, следующие после нее до команды endfunction(), без их исполнения.Кроме этого, создается новая команда с именем <имя ф-ции>.При ее вызове сохраненные ранее команды исполняются.При этом все 
ссылки на формальные параметры вида ${<параметр1>} заменяются значениями фактических аргументов, переданных команде.
	Любую команду, определенную при помощи function(), можно вызвать с переменным количеством аргов.Для доступа к ним можно использовать специальные переменные, приведенные ниже(картинка special_variables.png)

	Специалные переменные cmake для доступа к аргументам ф-ций
переменная 							значение
ARGC								общее число аргов
ARGV0, ARGV1,...					первый, второй и тд фактические арги
ARGV								список всех аргов
ARGN								список доп аргом, переданных в дополнение к объявленным
	Пример
Пример приведен в каталоге build11/CMakeLists.txt, также код ниже:

function(dump_vars)
        message(STATUS ============)
        message(STATUS "Dumping ${ARGC} variables:")
        foreach(VAR_NAME ${ARGN})
                message(STATUS "   ${VAR_NAME}== \"${${VAR_NAME}}\"")
        endforeach()
        message(STATUS ===========)
endfunction()
dump_vars(DATA GREETING VALUES)

создается команда с именем dump_vars, которая выполняет отладочную печать значений всех переменных, имена которых передаются ей в качестве аргументов.Список аргументов ${ARGN} 
обрабатывается при помощи команды foreach().Команда meaasge()(в теле цикла печатает имя очередной переменной, которое хранится в переменной VAR_NAME(подстановка ${VAR_NAME}, и ее значение 
${${VAR_NAME}}
	Вызов команды dump_vars() в последний строке приводит к выводу на печать инфы про переменные
Замечания:
-при помощи языковых конструкций вида ${<аргумент>} и ${${<аргумент>}} можно организовать передачу ф-ции переменных по ссылке.
-фунециональностью, аналогичной команде dump_vars() обладает команда cmake_print_variables() из стандартного модуля cmake CMakePrintHelpers
-в стандартном модуле CMakeParseArguments определена команда cmake_parse_arguments(), которая предназначена для облегчения синтаксического разбора списков аргументов ф-ций.С ее помощью 
можно определить требования для аргументов ф-ций, аналогично стандартным командам cmake
	
Пример 

cmake_minimum_required(VERSION 3.10)
function(quote VAR_NAME)
        set(${VAR_NAME} "\"${${VAR_NAME}}\"" PARENT_SCOPE)
endfunction()

set(STR "some string")
message(${STR})
quote(STR)
message(${STR})

	Здесь создается пользовательская команда quote(), которой передается имя переменной.Команда добавляет в начало и конец значения этой переменной символы двойных кавычек.Изменение переменной осуществляется командой set() с
аргументом PARENT_SCOPE, так как переменная находится во внешней по отношению к ф-ции quote() области действия.
	Команда return(), как и в других яп, позволяет досрочно прервать выполнение пользовательской команды и передать управление следуюшей за ней команде.Также команда return() способна прервать выполнение текущего модуля cmake и обработку подпроекта.
Таким образом, этой командой можно досрочно прервать исполнение команды include(), add_subdirectory() и find_packege().Наконец, командой return() можно прервать обработку описания проекта верхнего уровня.
	Команды работы с файлами
	get_filename_component()
	get_filename_component(
		<имя переменной> <путь к файлу> <компонент>
		[CACHE])
	get_filename_component(
		<имя переменной> <команда>
		PROGRAM [PROGRAM_ARGS <имя переменной аргументов>]
		[CACHE])
	С помощью команды get_filename_component() в первой форме можно выделить из заданного пути файловой системы(передается команде вторым аргументом) нужную часть(имя, ресширение и тд) или преобразовать путь к абсолютной форме.Относительные пути интерпритируются по отношению к
каталогу текущего подроетка.При этом файл или каталог, к которому указывается путь, не обязательно должен существовать.Возвращаемые пути содержат симолы "/" в качестве разделителей имен каталогов и не содержат последнего символа "/"
	Результат выполнения команды записывается в переменную, имя которой передается в качестве первого аргумента.Третий аргумент определяет, что именно должно быть получено в качестве результата(таблица 2.12 и картинка 2.12.png)
	Значения третьего аргумента команды
	get_filename_component(), определяющие возвращшаемый результат
аргумент 					возвращаемый результат
DIRECTORY					каталог, содержащий заданный файл или каталог
NAME 						имя с расширением баз каталога
EXT 						расширение(часть имени от первой точки)
NEW_WE						имя без каталога и расширения(до первой точки)
ABSOLUTE					полный путь относительно каталога подпроекта
REALPATH					как ABSOLUTE, но с разрешением символических ссылок

Замечание:значение REALPATH является единственным, при котором исполнение команды приводит к попытке обращения к файлу по указанному пути.
-при помощи необязательного аргумента CACHE можно поместить результирующую переменную в кэш
	Вторая форма команды ищет исполняемый файл по заданной командной строке с учетом системных путей поиска исполняемых файлов(значение переменной окружения PATH и тд)
Возвращается полный путь к файлу или пустая строка, если файл не найден.
-после необязательного аргумента PROGRAM_ARGS можно указать имя переменной, в которую будут записаны аргументы команды(начиная с первого пробела)
	Пример
Пусть требуетя указать в описании проекта списко файлов, из которых должна собираться некоторая цель.При этом для некоторых из этих CPP-файлов в каталоге проекта также существуют 
H-файлы, которые в списке не указаны.Их нужно найти и также включить в цель
	Эту задачу можно решить при помощи следующего файла

cmake_minimum_required(VERSION 2.8)

project(ex-find-h)

set(
        FILES_SRC
        src/main.cpp src/source.cpp)
set(FILES_H)
foreach(SRC IN LISTS FILES_SRC)
        get_filename_component(
                SRC_EXT "${SRC}" EXT)
        if(SRC_EXT STREQUAL .cpp)
                get_filename_component(
                SRC_FULL "${SRC}" ABSOLUTE)
                get_filename_component(
                SRC_DIR "${SRC_FULL}" DIRECTORY)
                get_filename_component(
                SRC_NAME "${SRC}" NAME_WE)
        set(SRC_H "${SRC_DIR}/${SRC_NAME}.h")
        if(EXISTS "${SRC_H}" AND NOT IS_DIRECTORY "${SRC_H}")
                message(STATUS "Found ${SRC_H}")
                list(APPEND FILES_H "${SRC_H}")
        endif()
endif()
endforeach()
add_executable(ex-find-h ${FILES_SRC} ${FILES_H})

	Здесь список файлов в переменной FILES_SRC обходится командой foreach().Для каждого пути выделяется расширение файла и проверяется, что оно равно строке .cpp.Дальше путь к файлу преобразуется к 
абсолютному, затем из него выделяются каталог и имя без расширения.Из них строится имя H-файла и проверяется, что такой файл существует и является файлом, а не каталогом, при помощи команды if().Если это так 
путь добавляется к списку в переменной FILES_H при помощи команды list(APPEND...)
Замечание:в make, cmake и других системах построения существуют средства для поиска файлов с заданными расширениями в каталоге проекта и автоматического из добавления к целям.Такой подход является плохой практикой, так как 
добавление новых исходных файлов не приведет к изменению описаний проектов.Из-за этого механизм автоматического перестроения в таких случаях не срабатывает и возникают непредвиденные ошибки времени компоновки.Кроме того, сильно 
замедляется построение крупных проектов.При этом поиск и автоматиеское включение заголовков, продемонстрированное в примере выше, вполне допустимы, так как заголовки не передаются системой построения на обработку компилятору, а только 
используется интегрированными средами для отображения в списке исходных файлов.
	find_file(),find_library(),find_path(),find_program()
	Эти команды предназанчены для поиска файла общего назначения(find_file()-как правило, зголовки, каталога, содержащего заданный файл(find_path()), библоитек (find_library()) или исполняемого файла(find_program()) позаданным именам в указываемых 
каталогах, а также в некоторых стандартных каталогах.
Замечание:если программный пакет поддерживает систему cmake, для его исполбзования вместо описанных здесь команд предпочтительнее применять более высокоуровневую команду find_packege()
	Все команды имеют почти одинаковый синтаксис аргументов и позволяют указать множество доп аргов для исключения тех или иных стандартных каталогов из поиска.Ниже приведен сокращенный вариант синтаксиса с основными настройками
	
<имя команды>(
	<имя переменной>
	<альтернативные имена>
	[HINTS <путь1,1>...<путь1,m>[ENV <имя окуржения1>]
	[PATHS <путь2,1>...<путь2,p>[ENV <имя окружения2>]]
	[PATH_SUFFIX <суффикс1>...<суффиксk>]
	[DOC <строка документации>])
<имя команды>::=
	find_file|find_library|find_path|find_program
<альтернативные имена>::=
	<имя>|NAMES <имя1>...<имяn>
	
	Команды сначала проверяют наличие переменной с заданным именем в кэше.Только если переменной там нет или ее значение равно ...-NOTFOUND, команды выполняют поиск и записывают найденный путь первого встроенного файла,удовлетворяющего критериям, в переменную кэша.Если файл не был найден,
в переменную запишется значение <имя переменной>-NOTFOUND.Таким образом, при последющих запусках cmake без очистки кэша ранее удавшийся поиск пропускается и генерирование проектов для конечной системы построения выполняется быстрее.
-после NAMES указывается одно или несколько альтернативных имен искомого файла.Команда find_program() может добавить к ним расширение исполняемог офайла,специфичное для системы, на которой выполняется инструмент cmake.Аналогично, команда find_library() может добавить префикс в начале имени и расширение в конце, например
lib<имя>.so.Если указывается одно имя, аргумент NAMES можно не передавать.
-после необязательного аргумента HINTS можно указать доп пути для поиска файла.Здесь рекомендуется указывать пути, которые были ранее найдены в результате исследования системы, например каталоги, где расположены другие ранее найденные файлы.После необязательного аргумента ENV можно указать имя переменной окружения, из которой будут прочитаны 
доп пути поиска.
-необязательный аргумент PATHS аналогичен аргументу HINTS,однако в отличие от него указываемые здесь пути будут проверены в последнюю очередь.Здесь рекуомендуется указывать при необходимости жестко заданные пути к каталогам, такие как C:\Program Files\SomeProg или /usr/local.Если другие необязательные арги не указаны(включая NAMES), аргумент PATHS также можно не указыать, указывая 
в команде пути к каталогам сразу после единственного имени файла.
-после необяхательного аргумента PATH_SUFFIXES можно указать дополнительные подкаталоги, которые будут использованы для поиска в каждом из каталогов
-после необязательного аргумента DOC можно указать строку документации, которая будет записана в кэш для создаваемой переменной 
	Поиск файла выполняется внутри каталогов в следующем порядке:
1)каталоги, пути к которым указаны в переменных кэша cmake:
-команды find_file() и find_path() ищут в каталогах:
	-<путь>/include для всех путей из специальной переменной CMAKE_PREFIX_PATH.Также, если установлено значение специальной переменной CMAKE_LIBRARY_ARCHITECTURE(архитектура библиотек), используются каталоги <путь>/include/<архитектура>
	-пути из переменной CMAKE_INCLUDE_PATH
	-пути из переменной CMAKE_FRAMEWORK_PATH
-команда find_library() ищет в каталогах:
	-<путь>/lib для всех путей из специальной переменной CMAKE_PREFIX_PATH.Также, если установлено значение специальной переменной CMAKE_LIBRARY_ARCHITECTURE, используются каталоги <путь>/lib/<архитектура>.При необходимости для заданной архитектуры также выполняется поиск в каталогах lib64(чтобы повлиять на это, можно вручную установив значение глобального свойства FIND_LIBRARY_USE_LIB64_PATHS)
	-пути из переменной CMAKE_LIBRARY_PATH
	-пути из переменной CMAKE_FRAMEWORK_PATH
-команда find_program() ищет в каталогах:
	-<путь>/bin и <путь>/sbin для путей из переменной CMAKE_PREFIX_PATH
	-пути из переменной CMAKE_PROGRAM_PATH
	-пути из переменной CMAKE_APPBUNDLE_PATH
2)аналогично пункту 1, но вместо указанных переменных cmake используются одноименные переменные окружения
3)пути, переданные командам после аргумента HINTS
4)пути, перечисленные в переменной окружения PATH.Команды find_file() и find_path() также используют переменную INCLUDE , а команда find_library()-LIB
5)аналогично пункту 1, но вместо переменных кэша cmake с именами CMAKE_..._PATH используются специальные переменные cmake с именами в форме CMAKE_SYSTEM_..._PATH (например, 
CMAKE_SYSTEM_PREFIX_PATH)
6)пути, переданные командам после аргумента PATHS

	В системах , которые не используют имени диска и тп в начале полного пути, возможно перенаправлание поиска в каталоги, пути к которым добавляются в виде префиксов в начало всех перечисленных выше путей.Это может быть удобно для выполнения 
кросс-компиляции, когда файлы сборки для целевой системы располагются в отдельных каталогах.Поиск выполняется в следующем порядке:
1)префиксы путей, перечисленные в специальной переменной cmake CMAKE_FIND_ROOT_PATH.При этом пути, попадающие в каталог, путь к которому хранится в переменной CMAKE_STAGING_PREFIX (путь установки при кросс-компиляции), не изменяются.
2)префикс из специальной переменной CMAKE_SYSROOT
3)далее выполняется поиск в исходных каталогах без префиксов
	Команды добавления специальных целей
	configure_file()
	configure_file(
		<входной файл> <выходной файл>
		[COPYONLY] [ESCAPE_QUOTES] [@ONLY]
		[NEWLINE_STYLE] <стиль>])
	<стиль>::=UNIX|DOS|WIN32|LF|CRLF
	Команда configure_file() предназначена для генерирования текстового файла по заданному входному файлу-образцу.Ф-ность команды аналогична средствам системы построения autotools, при помощи которых можно генерировать заголовочные файлы и make-файлы по их 
шаблонам.Входной файл копируется в выходной, при этом специальные конструкции в нем заменяются в соответствии со значениями переменных cmake.Кроме этого, в генерируемый проект добавляется правило построения, которое заставляет заново запускать инструмент cmake для повторной генерации после изменения входного файла
	Относительный путь для входного файла интерпритируется по отношению к каталогу текущего подпроекта(переменная CMAKE_CURRENT_SOURCE_DIR), для выходного-к текущему каталогу построения (CMAKE_CURRENT_BINARY_DIR).Для выходного файла можно указать существующий каталог, в этом случае файл будет записан в него с тем же именем, 
что и выходной файл
	Замене будут подвержены следующие конструкции входного файла
-конструкция @<имя переменной>@ заменяется в выходном файле значением переменной с соответствующим именем (пустой строкой, если переменная не определена)
-аналогично,конструкция ${<имя переменной>}
-конструкция:
	#cmakedefine <имя переменной> <строка>
	будет заменена на:
	#define <имя переменной> <преобразованная строка>
	если значение переменной истинно в соответствии с таблицей 2.1.png, и на строку:
	/*#undef <имя переменной> */
	если ложно.Правила преобразования также применяются к определению символа препроцессора (<строка>)
-аналогично в зависимости от истинности или ложности значения, конструкция:
	#cmakedefine01 <имя переменной>
	будет заменена на:
	#define <имя переменной> <1 или 0>
При помощи необяхательных аргументов, передаваемых команде, можно настроить способ преобразования файла:
-передача аргумента COPYONLY приводит к обычному копированию файла без преобрзования его содержимого
-передача ESCAPE_QUOTES приводит к добавлению сивола \ перед каждым символом двойной кавычки во вставляемые значения переменных.Это 
можнт быть необходимо для формирования в выходном файле на языках с/с++ строковых литералов
-передача @ONLY приводит к замене только конструкций вида @...@.Это может быть необходимо для генерирования по образцу сценариев CMake, где 
конструкции ${...} могут использоваться при работе с переменными.
-после аргумента NEWLINE_STYLE можно указать способ разделения строк:при помощи символов "\r\n"(CRLF,DOS,WIN32) или "\n"(LF,UNIX).Этот аргумент несовместим с аргументом COPYONLY
	Пример 
Пусть требуется добавить возможность для разрабатываемой программы вывода на печать своей версии-той, которая указана после аргумента VERSION команды project() в файле описания проекта
	Этот номер версии хранится в специальной переменной cmake с именем PROJECT_VERSION.Передать эту информацию в исходный код программы можно при помощи команды configure_file().Чтобы 
генерируемый файл был как можно меньше по объему, можно реализовать конфигурирование заголовочного файла, который хатем будет подключаться в коде программы.Таким образом, структура каталога 
проетка может быть такой как показано ниже

каталог проекта
	ex-version.cpp
	config.h.in-обрабатывается cmake(configure_file())
	CMakeLists.txt

	Содержимое файла config.h.in:

#cmakedefine PROJECT_VERSION "@PROJECT_VERSION@"
	
	Если знаение переменной PROJECT_VERSION ложно или не определено, в результате конфинурации будет создан файл со следующем содержимым:

/*#undef PROJECT_VERSION */
	
	Если же в переменной сожержится правильный номер версии , например <<1.0>>, будет сгенерировано следующее соедержимое выходного файла:

#define PROJECT_VERSION "1.0"
	
	Так как оставшаяся часть строки в файле шаблона после имени перменной тоже содержит конструкцию конфигурирования "@PROJECT_VERSION@", при формировании 
выходного файла она также будет обработана, заменившись значением переменной
	Содержимое файла ex-version.cpp:
	
#include "config.h"
#include <iostream>
const char g_acszVersion[] = 
#ifdef PROJECT_VERSION
	PROJECT_VERSION;
#else
	"<uncnown version>"
#endif

int main()
{
	std::cout<<"Version: "<<g_acszVersion<<std::endl;
}
	
	Здесь в начале подключается файл config.h, который должен быть сгенерирован в выходном каталоге и содержать (или не содержать) определение символа PROJECT_VERSION.Далее при определении строкового массива 
директивами препроцессора проверяется, ,были ли определен этот символ.Если да, то массив инициализируется литералом, который является определением PROJECT_VERSION,иначе-строка <<неизвестная версия>>
	Содержимое файла CMakeLists.txt:
		
cmake_minimum_required(VERSION 3.0)
#project(ex-version)
project(ex-version VERSION 1.0)
set(CMAKE_INCLUDE_CURRENT_DIR ON)
configure_file(
	config.h.in config.h)
add_executable(
	ex-version ex-version.cpp config.h.in)
	
	Здесь в команде project() устанавливается версия проекта.Чтобы эта возможность была доступной, выше устанавливается совместимость с минимальной версией cmake 3.0.Чтобы при компиляции добавляемой цели исполняемого файла был найден генерируемый в выходном каталоге файл config.h,специальной переменной 
CMAKE_INCLUDE_CURRENT_DIR устанавливается значение истины
	В последней строке файл config.h.in добавляется к списку исходных файлов цели исполняемого файла при помощи команды add_executable().Во время построения этот файл не будет обрабатываться инструментами компилятора, однако будет отображаться в списке исходных файлов при работе с интегрированными средами
	
	add_test(),enable_testing()
	add_test(
		NAME <имя теста>
		COMMAND <команда> [<аргумент1>...<аргументn>]
		[CONFIGURTIONS <конфигурация 1>...<конфигурацияn>]
		[WORKING_DIRECTORY <каталог>])
	
	enable_testing()

Команда add_test() добавляет тест к проекту
-при помощи аргумента NAME определяется имя теста
-при помощи аргумента COMMAND определяется команда вместе с аргументами, которая реализует тест.В случае успешного прохождения теста команда должна передать системе код возврата, равный 0.Аргумент <команда> может быть либо путем к исполняемому файлу, либо именем цели, определенной ранее при помощи команды add_executable().В последнем случае 
путь к создаваемому при помощи цели исполняемому файлу будет использован в качестве команды, реализующий тест
-после необяхательного аргумента CONFIGURTIONS можно указать список конфигураций, которыми будет ограниченно генерирование теста
-после необязательного аргумента WORKING_DIRECTORY можно задать путь к рабочему каталогу исполняемой команды, который определяет одноименное свойство теста.По умолчанию в качестве раобчего каталога выбирается подкаталог построения, соответствующий текущему каталогу подпроекта
	По умолчанию выполнение команды add_test() не вызывает никаких действий.Добавление тестов при помощи этой команды выполняется только после исполнения команды enable_testing().Эта команда должна вызываться в файле CMakeLists.txt для проекта верхнего уровня.В этом случае в генерируем описании проекта создается доп цель, которая называется test при использовании 
системы make, проект RUN_TESTS для Microsoft Visual Studio и тд. При запуске цели в случае неудачного исполнения какого либо теста(с ненулевым кодом возврата) утилита make или подобная сама завершается с ненулевым кодом возврата.Это позволяет организовать автоматическое тестирование проекта при построении 
	В определении правил для цели тестирования используется вызов утилиты ctest из состава cmake.Вместо исполнения цели тестирования системой построения можно вызвать эту команду непосредственно.В этом случае появляется возможность передать ей доп аргументы командной строки, представляющие расширенные возможности(орпеделение таймаута, 
выбор подмножества тестов и тд).При использовании инструмента make доп арги утилите ctest можно также передать при помощи переменной окружения ARGS
	Тестирование является важной составной частью процесса разработки по.Автоматические тесты служат двум целям:
-пользователю программного пакета они предоставляют возможность проверить корректность построения пакета в его системе 
-разрабу программного пакета, вносящему изменения в исходный код, они позволяют убедиться, что эти изменения не нарушают прежнюю ф-ность.
	Автоматическое тестирование реализовано в описаниях проектов для многих библ с открытым исходным кодом, выполняющих математические расчеты(GMP,LAPACK и тд).cmake облегчает создание подобных целей тестирования.При разработке многих сложных программных проектов оправданно внедрение практики, в соответствии с которой любые изменения от разрабов попадают в центральный
репозиторий только после успещного прохождения тестов.Для автоматизации этого процесса существуют различные средства, например система обзора кода Gerrit.Таким образом, использование подобных систем совместно с cmake позволяет организовать автоматическое тестировани изменений кода перед помещением его в основную ветвь репа.
	Пример 
Пусть проект библы имеет структуру как на рисунке 2.11.png, все файлы проекта лижат в каталоге build16:
	Пусть код библы для примера выглядит так, файл mylib.cpp:

#include "mylib.h"
int answer(){return 42;}

	файл mylib.h:
	
#pragma once
int answer();

	файл CMakeLists.txt для подроекта библы:
	
add_library(mylib mylib.cpp mylib.h)

	Как можно видеть, код библы вместе с ее описанием в системе cmake не имеет каких либо отличий от других похожих примеров от рассмотренных ранее 
	Теперь перейдем к разработке теста.Файл mylib_test.cpp выглядит так :

#include "mylib.h"

int main()
{
	return (answer()==42?0:1);
}
	
	Программа завершается с передачей вызыающей системе нулевого кода возврата, если вызываемая ф-ция библы (answer()) возвращает ожидаемое от нее значение,и ненулквое в противном случае
	Файл CMakeLists.txt для проекта теста
	
add_executable(mylib_test mylib_test.cpp)

include_directories(../lib)

target_link_libraries(mylib_test mylib)

add_test(
	NAME mylib_test_1
	COMMAND mylib_test
	)
	
	Здесь определяется цель mylib_test, которая генерирует исполняемый файл, связваемый с библой.Команда add_test() создает тест с исполняемым файлом-результатом работы цели mylib_test
	Файл CMakeLists.txt описания проекта верхнего уровня

cmake_minimum_required(VERSION 2.8)

project(mylib)

enable_testing)(

add_subdirectory(lib)

add_subdirectory(test)

	Здесь перед добавлением подпроектов lib и test вызыается команда enable_testing(), которая включает создение цели тестирования
	В POSIX-совместной системе команды построения и тестирования проекта могут быть следующими:

cmake ../../work/cross/mylib
make 
make test
	
	При необходимости можно передать доп аргумнеты утилите ctest, реализующей тестирование, при помощи переменной ARGS:

make test ARGS="--timeout 1"

	Здесь утилите ctest передается аргумент, задающий таймаут для теста, равный 1с
	В случае успешного прохождения теста вывод команды make test будет подобен следующему:
	
Test project /mnt/c/Users/PC/Desktop/study/buid_system_cmake/projects/build16
    Start 1: mylib_test_1
1/1 Test #1: mylib_test_1 .....................   Passed    0.03 sec

100% tests passed, 0 tests failed out of 1

Total Test time (real) =   0.06 sec

	Если же ф-ция answer() из библы вернет какое-либо другое значение, вывод команды make test изменится на следующий:
	
Test project /mnt/c/Users/PC/Desktop/study/buid_system_cmake/projects/build16
    Start 1: mylib_test_1
1/1 Test #1: mylib_test_1 .....................***Failed    0.02 sec

0% tests passed, 1 tests failed out of 1

Total Test time (real) =   0.04 sec

The following tests FAILED:
          1 - mylib_test_1 (Failed)
Errors while running CTest
Makefile:83: recipe for target 'test' failed
make: *** [test] Error 8

Замечания:
-после запуска тестов в подкаталоге Testing/Temporary каталога построения проекта будет создан файл LastTesting.log с подробностями запуска тестов.В частоности,там будет сохранена инфа, выводимая тестовыми программами в stdout
-ограничить время работы теста можно также из сценария cmake установкой св-ва TIMEOUT в заданное количество секунд (команда set_property())
-для разработки сложных тестовых приложений удобно пользоваться сторонними каркасами модульного тестирования,такими как google test и qt test
	install()
	Команда install() добавляет правило установки сущности к специальной цели генерируемого проекта(цель install для системы make, проект INSTALL для microsoft visual studio и тд).При помощи этой команды можно создать правила для выполнения следующих действий:
-установки результатов выполнения целей проекта(команды add_executable(), add_library())
-установки файлов из каталога проекта
-установки подкаталогов из каталога проекта с возможностью отбора содержащихся в них файлов по маске
-запуска произвольных сценариев cmake 
-генерирования модулей cmake, облегчающих использование устанавливаемых библ в сторонних проетах.
	После обработки описания системой cmake в выходном каталоге каждого подпроекта генерируется вспомогательный сценарий cmake_install.cmake, интерпритация которого и осуществляет фактическую установку.Вызов инструмента cmake для исполнения этого сценария записан в правилах 
install и тд.
	Команда install() способна принимать мн-во настроек при помощи своих аргументов, мы рассмотрим только основные из них.
	Для установки результатов целей предназначена следующая форма команды install():

install(
	TARGETS <имя цели1>...<имя целиn>
	[EXPORT <имя экспорта>]
	[
		[ARCHIVE | LIBRARY | RUNTIME]
		[DESTINATION <каталог>]
		[CONFIGURTIONS [Debug | Relese | ... ]]
		[COMPONENT <имя компонента>]
	...)
	
	Команда добавляет к цели правила для установки результатов выполнения заданных целей
-после необязательного аргумента EXPORT можно определить имя для устанавливаемых файлов, которое затем можно использовать для ссылки на них в команде определения првила генерирования сценария cmake (intstall(EXPORT...))

-при помощи необязательных аргументов ARCHIVE, LIBRARY и тд можно определить, к каким видам файлов относятся следующие настройки(DESTINATION и тд).По умолчанию последующие настройки относятся ко всем файлам.Например, исполняемые файлы и динамические библы в системах windows 
относятся к категории RUNTIME, статические библы, включая библы импорта, относятся к категории ARCHIVE

-после необязательного аргумента DESTINATION можно указать путь к каталогу, в который должны быть установлены файлы.Относительные пути определяют каталоги относительного каталога установки.Каталог установки определятеся специальной переменной cmake CMAKE_INSTALL_PREFIX, в которой по умолчанию храниться путь 
/usr/local для POSIX-совместимых систем и путь к подкаталогу с именем проекта внутри каталога Program Files или Program Files(x86) для систем windows

-после необязательного аргумента COMPONENT можно задать имя компонента, с которым будет связано правило установки.При помощи компонент можно организовать возможность выбора пользователем для установки разных частей программного пакета.Выбор компонента определяется значением переменной cmake COMPONENT.Пустое ее значение 
по умолчанию приводит к установке всех компонент.
	В одной команде можно указать несколько групп свойств, относящихся к различным видам файлов из перечисленных целей.При помощи нескольких команд install() можно установить одни и те же файлы в разные каталоги
Замечание:все цели, обрабатываемые командой install(), должны быть определены в том же самом подкаталоге, в описании которого вызывается эта команда.
	
	install(
		FILE | PROGRAMS <файл1>...<файлn>
		DESTINATION <каталог>
		[CONFIGURTIONS [Debug | Release |...]]
		[COMPONENT <имя компонента>]
		[RENAME <имя>]
	)
	
	Эта форма команды install() добавляет правила для установки заданных файлов.Относительные пути для устанавливаемых файлов интерпритируются по отношению к каталогу текущего (под)проекта
-указание аргумента PROGRAMS вместо FILES приводит к тому, что на POSIX-совместных системах установленные файлы будут иметь права доступа на исполнение.Эта возможность предназанчена прежде всего для установки сценариев из каталога исходных файлов проекта
-аргументы DESTINATION и тд имеют то же значение что и для команды INSTALL(TARGETS...)
-после необязательного аргумента RENAME можно задать новое имя устанавливаемого файла, отличное от исходного.Этот аргумент допустим только в случае указания одного исходного файла.
	
	install(
		DIRECTORY [<каталог1>...<каталогn>]
		DESTINATION <каталог>
		[CONFIGURTIONS [Debug |Release|...]]
		[COMPONENT <имя компонента>]
		[FILES_MATCHING]
		[
			[PATTERN <маска> |REGEX<регулярка>]
			[EXCLUDE]
		]
		[...]
		)
	
	Эта форма команды install() добавляет праивила для установки файлов внутри заданных каталогов.Относительные пути для устанавливаемых каталогов интерпритируются по отнощению к каталогу текущего (под)проекта.Если список каталогов пуст, в каталоге 
установки создается пустой каталог, имя которого указано при помощи аргумента DESTINATION
	В выходной каталог копируется структура каталогов-источников, при этом последние компоненты путей этих подкаталогов (после последней /) добавляются к пути каталога-приемника
Пример в каталоге build17 и ниже:

Команда:

install(DIRECTORY dir1 DESTINATION ./dir2/)

добавит следующую структуру каталогов в выходном каталоге (рис 2.12.include.png)
-аргументы DESTINATION и тд имеют то же самое значение что и для команды install(TERGETS...)

-в конце команды можно указать несколько групп сво-ств для отбора файлов и каталогов, удовлетворяющих заданной масе или решулярному выражению.При помощи необязательного аргумента FILES_MATCHING перед началом первой группы можно указать, что проеверяться на соответсивие будут не только имена файлов, а не каталогов.Далее 
могут следовать несколько аргументов PATTERN и REGEX, устанавливающих соответстиве на языке масок командных оболочек большинства систем или решулярных выражений соответсивенно.Аргумент EXCLUDE после образца соответствия означает, что заданные файлы или каталоги будут исключены из установки, а не включены в нее.

	install(
	[
		[SCRIPT <файл сценария>][CODE <код_cmake>]
	]
	[COMPONENT <имя компонента>]
	[...]
	)
	
	Эта форма команды install() добавляет правила для запуска сценариев cmake во время установки
-после необяхательного аргумента SCRIPT указывается путь к файлу сценария cmake.Относительные пути интерпритируются по отношению к каталогу проекта.
-после необязательного аргумента CODE определяется код cmake, заключенный в двойные ковычки
-необязательный аргумент COMPONENT имеет то же значение, что и для команды install(TERGETS...)
	Групп аргументов, начинающихся со SCRIPT или CODE, может быть несколько.
	install(
		EXPORT <имя экспорта>
		DESTINATION <каталог>
		[NAMESPACE <имя пр-ва имен>]
		[FILE <имя файла>.cmake]
		[CONFIGURTIONS [Debug | Release |...]]
		[COMPONENT <имя компонента>]
		)
	
	Эта форма команды install() генерирует в выходном каталоге модуль cmake, который хатем можно будет использовать для подключения установленной библы в стороннем проекте.В файле cmake этого проекта можно подключить сценарий при попомощи команды include(), после чего связывать цели проекта с экспортируемыми целями.
-после аргумента EXPORT указывается имя экспортируемого набора файлов, которое должно быть ранее определено при помощи необязательного аргумента EXPORT после команды install(TARGETS...)
-аргумент DESTINATION, а также необязательные аргументы CONFIGURTIONS и COMPONENT имеют те же значения,  что и для команды intstall(TARGETS...)
-после необязательного аргумента NAMESPACE можно указать пфикс, который булет добавляться к имени экспортируемых целей.При помощи этих имен в импортирующем проекте можно будет ссылаться на эти цели.
-после необязательного аргумента FILE можно указать имя файла сценария.По умолчанию используется имя <имя экспорта>.cmake 
Замечение:в зависимости от выходного каталога для исполнения цели установки могут потребоваться права админа для данной системы.
	Пример
Вернемся к примеру проекта , который остоял из двух библиотек и использовавшего их исполняемого файла.Этот пример демонстрировал, как при помощи присваиваний специальным переменным можно добиться структуры подкаталогов в каталоге построения, совместимой с рекомендациями GNU.Попробуем теперь определить правила для установки проекта с подобной структурой в каталоге установки.Кроме этого, разделим 
файлы на два компонента:для обычного пользователя и для разраба.Очевидно, что для пользователя достаточно установки исполняемого файла my_program и динамических(разделяемых) библ my_lib1/2(если тип библ-SHARED).Для разраба кроме этих файлов также будут нужны статические библы/библы импорта, заголовки из подкаталогов my_lib1/2 и сценария cmake для подключения библ.
	Файл CMakeLists.txt подкаталога my_lib1, решающий указанные задачи, может выглядеть следующим образом:
	
add_library(my_library_1 f.cpp f.h)
get_property(
	LIB_TYPE
	TARGET my_library_1
	PROPERTY TYPE
	)
if(LIB_TYPE STREQUAL SHARED_LIBRARY)
	install(
		TARGETS my_library_1
		COMPONENT user
		RUNTIME
		DESTINATION bin
		LIBRARY
		DESTINATION lib
	)
endif()
install(
	TARGETS my_library_1
	EXPORT my_library_1
	COMPONENT developer
	RUNTIME
	DESTINATION bin
	LIBRARY
	DESTINATION lib
	ARCHIVE
	DESTINATION lib
)
install(
	DIRECTORY .
	DESTINATION include
	COMPONENT developer
	FILES_MATCHING
	PATTERN "*.h"
)
install(
	EXPORT my_library_1
	DESTINATION share
	COMPONENT developer
)
	
	Здесь первая команда install() отвечает за установку файлов библиотек, необъодимых только для запуска программы.Если тип собираемых библ статический, при ее исполнении cmake выведет сообщение об ошибке из-за того, что в команде отсутствет группа настроек STATIC.Поэтому сначала проверяется тип библы при помощи свойства TYPE ее цели.Свойство считывается при помощи команды get_property().При помощи 
условного оператора команда исполняется, только если тип библы-SHARED.В системах windows тип выходного файла дин библы -RUNTIME, и он устанавливается в подкаталог bin вместе с исполняемым файлом.В POSIX-системах разделяемая библа помещается в подкаталог lib.Группа настроек STATIC в команде пропущена, из-за чего библа импорта установлена не будет.
	add_custom_target()
	add_custom_target(
		<логическое имя>
		[ALL]
		[<путь к команде1> [<аргумент1,1>...<аргумент1,m>]]
		[
			COMMAND
				<путь к команде2>[<аргумент2,1>...<аургмент2,n>]
			...
		]
		[DEPENDS <файл1>...<файлk>]
		[WORKING_DIRECTORY <каталог>]
		[VERBATIM]
		[SOURCES <исходный модуль1>...<исходный модуль>]
	)
	
	Команда добавляет к проекту цель, построение которой заключается в исполнении заданных инструментов.При этом конечная система построения считает, что цель должна перестариваться всегда, вне зависимости от того, какие файлы создаются при исполнении этих инструментов(как будто дата последнего изменения цели всегда старше требуемого).Таким образом, цель, создаваемая при помощи этой команды , ведет себя аналогично фальшивым целям системы make
	Иногда команда add_custom_target() применяется для создания цели, построение которой приводит к последовательному построению нескольких других ранее определенных целей.В этом случае список команд на исполнение инструментов будет пустым, а зависимость данной цели от других устанавлиается при помощи команды add_dependencies() или от файлов при помощи аргумента DEPENDS
-по умолчанию, создаваемая цель не учавствует в построении общего проекта(цель all в make и тд).Обычно это имеет смысл, поскольку фальшивиые цели запускаются на построение каждый раз при их использовании.Они служат для выполнения некоторых специфических действий ,используемых нечасто.Если все же необходимо, чтобы данная цель учавствовала в построении общей цели, можно использовать необязательный аргумент ALL, команды add_custom_target
-несколько последовательных команд оболочки, возможно, вместе с их аргументами командной строки указываются друг за другом, каждая последующая отделяется от предыдущей аргументом COMMAND.Перед первой командой аргумнет COMMAND указывать необязательно.При построении цели команды будут выполняться в порядке их указания в аргумнетах команды add_custom_target()
-после необязательного аргумента DEPENDS можно указать файлы, от которых должна зависеть цель.Здесь также можно указывать выходные файлы для команды add_custom_command(), вызыванных в текузем подпроекте.Команда add_custom_command() похожа на команду add_custom_target().Основное ее отличие заключается в том, что в ней явно указываются выходные файлы, создаваемые в результате построения цели.
-после необязательного аргумента WORKING_DIRECTORY можно определить путь к рабочему каталогу для вызываемых инструментов.Относительные пути интерпритируются по отношению к подкаталогу построения для текущего (под)проекта
-некоторые из символов, встречающихся в аргументах команд цели, могут иметь спеиальное значение в командах оболочек различных систем.При использовании необязательного аргумента VERBATIM все аргументы командной строки будут при необходимости дополнены зависящими от системы escape-символами так, чтобы они были переданы инструментам в неизменном виде.Например строка $n будет интерпритирована оолочокй bash как подстановка занчения переменной n.Чтобы передать такую строку в качестве аргумнета cli, необходимо 
добавить перед $ символ \
-после необяхательного аргумента SOURCES можно указать исходные файлы для создаваемой цели.Эта настройка никак не влияет на генерируемые правила и может быть использована исключительно для удобства разраба:указанные исходные файлы будут отображаться интегрироанными средами как входящие в проект.Эти файлы могут иметь какое-либо отношение у построению цели.Например, они могут обрабатываться вызываемыми инструментами.